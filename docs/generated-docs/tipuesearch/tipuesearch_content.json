{"pages":[{"title":"CoreShop - Pimcore eCommerce Framework","text":"CoreShop Documentation This documentation section provides all information you need to use the CoreShop - Pimcore eCommerce Framework We've aimed this part of the documentation at a developer's audience. CoreShop provides a fully flexible and extendable eCommerce Solution for Pimcore. If you want to know more about Pimcore, please visit pimcore.com. Documentation Overview The Core Framework documentation is divided into three sections that aim to guide the reader through its first use of the platform: See the Getting Started section for an overview and information about the installation process. See the Bundles section for details about the different Bundles CoreShop provides. See the User Documentation section for documentation configuration of CoreShop. See the Development section for documentation about developing with CoreShop. Additional resources for getting started with CoreShop CoreShop Demo: See CoreShop in action and also use it as a blueprint application for your own implementations.","tags":"","url":"index.html"},{"title":"Getting Started","text":"Getting Started with CoreShop This section provides a quick getting started tutorial for CoreShop and covers the following topics: Installation of Pimcore Architecture Overview Upgrade Notes Difference to the eCommerce Framework UI Documentation Developer Documentation","tags":"","url":"Getting_Started\/index.html"},{"title":"Installation","text":"CoreShop Installation You need a running instance of Pimcore on your system before you can install CoreShop. You can setup your own example: Install with composer composer require coreshop\/core-shop ^3.0 Run enable Bundle command php bin\/console pimcore:bundle:enable CoreShopCoreBundle Run Install Command php bin\/console coreshop:install Optional: Install Demo Data php bin\/console coreshop:install:demo Messenger CoreShop also uses Symfony Messenger for async tasks like sending E-Mails or Processing DataObjects for the Index. Please run these 2 transports to process the data bin\/console messenger:consume coreshop_notification coreshop_index --time-limit=300 Payment CoreShop uses Payum for Payment. Checkout Payums Documentation on how to add payment providers. Payment providers are implemented as Pimcore Plugin. They can be installed using composer. Here you can find all available payment modules via composer Payum Documentation","tags":"","url":"Getting_Started\/Installation.html"},{"title":"Architecture Overview","text":"CoreShop Architecture CoreShop is completely open source (GPl license) and free, maintained by diverse and creative community of developers and companies. What are our core values and what makes us different from other solutions? Components based approach Unlimited flexibility and simple customization Developer-friendly, using latest technologies Highest quality of code The Three Natures of CoreShop CoreShop is constructed from fully decoupled and flexible e-commerce components for PHP. It is also a set of Symfony bundles, which integrate the components into the full-stack framework. On top of that, CoreShop is also a complete eCommerce suite crafted from all these building blocks. It is your choice how to use CoreShop, you can benefit from the components with any framework, integrate selected bundles into existing or new Pimcore app or built your application on top of CoreShop Suite. CoreShop Suite This book is about our full-stack eCommerce suite, which is a standard Pimcore Bundle providing the most common webshop and a foundation for custom systems. Leveraging Symfony Bundles If you prefer to build your very custom system step by step and from scratch, you can integrate the standalone Symfony bundles. For the installation instructions, please refer to the appropriate bundle documentation. Difference to the official Pimcore eCommerce Framework The eCommerce Framework provides you with a basic Toolset for eCommerce Development. CoreShop gives you a feature-rich Toolset of common needed Tools for rich and complex eCommerce Solutions. Example I: the Framework does'nt give you the full opportunity for calculating complex Shipping Prices. You need to code it by yourself. CoreShop provides you with Carriers and Shipping Rules to do that. CoreShops Bundles are build to be used individually. The CoreBundle combines all the Features. Architecture Overview CoreShop Suite is build on CoreShop Components and Bundles. The CoreBundle and CoreComponent glues all different Bundles and Components into one eCommerce Suite for B2B and B2C Solutions.","tags":"","url":"Getting_Started\/Architecture_Overview.html"},{"title":"Upgrade Notes","text":"CoreShop Upgrade Notes Always check this page for some important upgrade notes before updating to the latest coreshop build. 2.0.0-beta.3 to 2.0.0-beta.4 BC break: All occurrences of parameters coreshop.all.stack.pimcore_class_ids, &quot;application&quot;.model.&quot;class&quot;.pimcore_class_id, coreshop.all.pimcore_classes.ids have been removed. Inject the corresponding Repository and use classId function instead Pimcore: CoreShop now requires at least Pimcore 5.4.0. You need to update Pimcore to the at least 5.4.0 in order to use\/update CoreShop. Product Price Calculation In order to allow custom price calculation on API Level, we changed the way CoreShop calculates product prices by introducing a new parameter to every PriceCalculation Interface. Price Calculator Conditions are not anymore using a Live context, instead it gets passed via API. Following interfaces have changed: CoreShop\\Component\\Core\\Product\\TaxedProductPriceCalculatorInterface CoreShop\\Component\\Order\\Calculator\\PurchasableDiscountCalculatorInterface CoreShop\\Component\\Order\\Calculator\\PurchasableDiscountPriceCalculatorInterface CoreShop\\Component\\Order\\Calculator\\PurchasablePriceCalculatorInterface CoreShop\\Component\\Order\\Calculator\\PurchasableRetailPriceCalculatorInterface CoreShop\\Component\\Product\\Calculator\\ProductDiscountCalculatorInterface CoreShop\\Component\\Product\\Calculator\\ProductDiscountPriceCalculatorInterface CoreShop\\Component\\Product\\Calculator\\ProductPriceCalculatorInterface CoreShop\\Component\\Product\\Calculator\\ProductRetailPriceCalculatorInterface CoreShop\\Component\\Product\\Rule\\Action\\ProductDiscountActionProcessorInterface CoreShop\\Component\\Product\\Rule\\Action\\ProductDiscountPriceActionProcessorInterface CoreShop\\Component\\Product\\Rule\\Action\\ProductDiscountPriceActionProcessorInterface CoreShop\\Component\\Product\\Rule\\Action\\ProductPriceActionProcessorInterface CoreShop\\Component\\Product\\Rule\\Fetcher\\ValidRulesFetcherInterface If you have anything customized with those classes, please change them accordingly. If you use the PriceCalculator Service directly, you also need to change the call from $this-&gt;priceCalculator-&gt;getPrice($object, true) to $this-&gt;priceCalculator-&gt;getPrice($object, [ 'store' =&gt; $store, 'country' =&gt; $country, 'customer' =&gt; $customer, 'currency' $currency, 'cart' =&gt; $cart ], true) The new second argument, is the Context for which you want to get the Price. This is highly depends on your need. On a default CoreShop setup, the context can be fetched form the ShopperContext Service like this: return [ 'store' =&gt; $this-&gt;shopperContext-&gt;getStore(), 'customer' =&gt; $this-&gt;shopperContext-&gt;hasCustomer() ? $this-&gt;shopperContext-&gt;getCustomer() : null, 'currency' =&gt; $this-&gt;shopperContext-&gt;getCurrency(), 'country' =&gt; $this-&gt;shopperContext-&gt;getCountry(), 'cart' =&gt; $this-&gt;shopperContext-&gt;getCart() ]; CoreShop makes that easier for you, you can just use $this-&gt;shoppperContext-&gt;getContext(). But be aware, the Shopper Context is only in a Web Request available. When you work on a CLI Level, you have to define the context yourself. If you already have a cart and want to calculate the price for the cart, the context is a bit different, cause it resolves from the cart $context = [ 'store' =&gt; $cart-&gt;getStore(), 'customer' =&gt; $cart-&gt;getCustomer() ?: null, 'currency' =&gt; $cart-&gt;getCurrency(), 'country' =&gt; $cart-&gt;getStore()-&gt;getBaseCountry(), 'cart' =&gt; $cart ]; Taxation Tax Rule Store relation has been removed as it makes currently no sense. Tracking Tracking bundle has completely been refactored in order to support more use-cases than just ecommerce. If you have any customizations made, please check the current implementation to adapt your changes. Order Invoice Due to changes in adjustments, we also need to change OrderInvoice\/OrderInvoiceItem. After you have migrated to the latest version you also have to remove some fields: CoreShopOrderInvoice totalTax baseTotalTax subtotalTax baseSubtotalTax shippingTax baseShippingTax taxes baseTaxes discountTax baseDiscountTax discountNet discountGross baseDiscountNet baseDiscountGross shippingNet shippingGross baseShippingNet baseShippingGross shippingTaxRate CoreShopOrderInvoiceItem totalTax baseTotalTax taxes baseTaxes Adjustments BC break \/ New Feature There are several deprecated class fields. After you have migrated to the latest version you also have to remove them: CoreShopOrder \/ CoreShopQuote shippingGross shippingNet shippingTax discountGross discountNet discountTax baseShippingNet baseShippingGross baseShippingTax baseDiscountNet baseDiscountGross totalTax baseTotalTax subTotalTax baseSubtotalTax CoreShopOrderItem \/ CoreShopQuoteItem totalTax baseTotalTax CoreShopCart shippingGross shippingNet discountGross discountNet 2.0.0-beta.2 to 2.0.0-beta.3 BC break Signature of following interfaces changed: CoreShop\\Component\\Index\\Interpreter\\InterpreterInterface: public function interpret($value, IndexableInterface $object, IndexColumnInterface $config, $interpreterConfig = []); CoreShop\\Component\\Index\\Interpreter\\LocalizedInterpreterInterface: public function interpretForLanguage($language, $value, IndexableInterface $object, IndexColumnInterface $config, $interpreterConfig = []); CoreShop\\Component\\Index\\Interpreter\\RelationInterpreterInterface: public function interpretRelational($value, IndexableInterface $indexable, IndexColumnInterface $config, $interpreterConfig = []); CoreShop\\Component\\Customer\\Model\\UserInterface::ROLE_DEFAULT renamed CoreShop\\Component\\Customer\\Model\\UserInterface::CORESHOP_ROLE_DEFAULT CoreShop\\Component\\Customer\\Model\\UserInterface::ROLE_SUPER_ADMIN renamed CoreShop\\Component\\Customer\\Model\\UserInterface::CORESHOP_ROLE_SUPER_ADMIN BC break Shipment \/ Invoice Creation via API changed Before adding a new Shipment \/ Invoice you need to dispatch a request state to your order. Read more about it here and here. BC break getName in CoreShop\\Component\\Index\\Model\\IndexableInterface has been changed to getIndexableName as getName could eventually conflict with a non localized Pimcore Field BC break getEnabled in CoreShop\\Component\\Index\\Model\\IndexableInterface has been changed to getIndexableEnabled as getEnabled could eventually conflict with a localized Pimcore Field 2.0.0-beta.1 to 2.0.0-beta.2 Link Generator implemented. If you want to use nice urls, you need to add the link generator service: CoreShopProduct: add @coreshop.object.link_generator.product as Link Provider CoreShopCategory: add @coreshop.object.link_generator.category as Link Provider Change {{ path('') }} to {{ coreshop_path('') }}. You may want to checkout the FrontendBundle to get a deeper insight. Deprecated Field Names in - CoreShop\\Component\\Payment\\Model\\PaymentInterface`: getName is now getTitle getOrderId is now getOrder and directly returns a OrderInterface Deprecated Field Names in - CoreShop\\Component\\Shipping\\Model\\CarrierInterface: getLabel is not getTitle getName is now getIdentifier 2.0.0-alpha.4 to 2.0.0-beta.1 BC break Signature of following interfaces changed: CoreShop\\Component\\Index\\Interpreter\\InterpreterInterface: public function interpret($value, IndexableInterface $object, IndexColumnInterface $config); CoreShop\\Component\\Index\\Interpreter\\LocalizedInterpreterInterface: public function interpretForLanguage($language, $value, IndexableInterface $object, IndexColumnInterface $config); CoreShop\\Component\\Index\\Interpreter\\RelationInterpreterInterface: public function interpretRelational($value, IndexableInterface $indexable, IndexColumnInterface $config); BC break CoreShop now takes advantage of the dependent bundle feature introduced in Pimcore 5.1.2. Therefore, all bundles are now automatically loaded. This is a BC break, as when updating, you might run into issues. To solve the issues, check following things: remove RegisterBundles entry from app\/AppKernel.php remove loading CoreShopCoreBundle Configuration in app\/config.yml enable CoreShopCoreBundle via CLI or manually in var\/config\/extensions.php: &quot;CoreShop\\\\Bundle\\\\CoreBundle\\\\CoreShopCoreBundle&quot; =&gt; TRUE BC break Upgraded Default Layout to Bootstrap 4. This will most certainly cause issues when you just override certain templates. Best would be to copy all templates from before the Bootstrap 4 Upgrade. 2.0.0-alpha.4 to 2.0.0-alpha.5 BC break added Component\\Core\\Model\\OrderItem and Component\\Core\\Model\\QuoteItem. If you already customized them, inherit them from the Core Models. BC break changed the way CoreShop processes Cart-Rules. If you implemented a custom-condition, inherit from CoreShop\\Component\\Order\\Cart\\Rule\\Condition\\AbstractConditionChecker and implement isCartRuleValid instead of isValid Deprecated: remove cart\/add-price-rule\/ static route. 2.0.0-alpha.3 to 2.0.0-alpha.4 BC break decoupled MoneyBundle from CurrencyBundle, therefore the Twig Extension for Money Conversion went to the CurrencyBundle. Therefore the name of that extension was renamed from coreshop_convert_money to coreshop_convert_currency. If you use it directly in your code, please rename all of them. Deprecated CoreShopAdminBundle which responsability was only handling installation and deliviering pimcore resources like JS and CSS files. Installation has been moved to CoreShopCoreBundle Delivering of resources is now handled by CoreShopResourceBundle, this also makes it easier to use CoreShop Bundles without handling resources yourself. 2.0.0-alpha.2 to 2.0.0-alpha.3 BC break getPrice in PurchasableInterface and ProductInterface has been removed. In favor of this a new coreShopStorePrice editable has been introduced, which stores prices for each store. This makes handling of multiple currencies way more elegant. If you still want to use the old getPrice, create a new Subclass of \\CoreShop\\Component\\Core\\Model\\Product, implement \\CoreShop\\Component\\Order\\Model\\PriceAwarePurchasableInterface and set your class to CoreShopProduct parents. V1 to V2 CoreShop 2 is not backward compatible. Due to the framework change, we decided to re-make CoreShop from scratch. If you still have instances running and want to migrate, there is a basic migration way which gets you data from V1 to V2. Export from CoreShop1 Import into CoreShop2 Within V1 Nothing available","tags":"","url":"Getting_Started\/Upgrade_Notes.html"},{"title":"Difference to ecommerce Framework","text":"CoreShop vs. eCommerce Framework The idea behind CoreShop is totally different to the eCommerce framework. The eCommerce framework gives you skeleton for building eCommerce applications and heavily depends on you doing all the things. CoreShop, on the other hand, comes full-featured with a rich toolset of optional Components which you can use, or not use, for your ecommerce Application. In other words: CoreShop is the framework on steroids :) Feature Comparison Feature eCommerce Framework CoreShop Product Management \u221a \u221a Product Restrictions X \u221a Product Variants \u221a \u221a Category Management \u221a \u221a Customer Management X \u221a Customer Address Management X \u221a Localization X \u221a Currency Management X \u221a Country Management X \u221a Taxation \u221a \u221a Payment Management \u221a \u221a Supported Payment Providers - Wirecard Qpay \u221a \u221a - Wirecard Seamless \u221a \u221a - Datatrans \u221a \u221a - Klarna \u221a \u221a - Recurring Payments \u221a \u221a - PayPal Express X \u221a - PayPal Pro Checkout X \u221a - PayPal Pro Hosted X \u221a - PayPal Masspay X \u221a - PayPal Rest X \u221a - Stripe.js X \u221a - Stripe Checkout X \u221a - Authorize.NET AIM X \u221a - Be2Bill Credit Card X \u221a - Be2Bill Offsite X \u221a - Payex X \u221a - Offline X \u221a - Payum and Omnipay X \u221a Voucher Codes \u221a \u221a Catalog Price Rules \u221a \u221a Product Specific Price Rules X \u221a Product Facet Index \u221a \u221a Multi Theme Supported X \u221a Carrier Management X \u221a Shipping Calculation X \u221a Order Management \u221a \u221a Order Workflow X \u221a Order Invoice Generation X \u221a Order Shipment Generation X \u221a Quotes Management X \u221a Reporting X \u221a Multi Store\/Tenant \u221a \u221a eCommerce Tracking \u221a \u221a Configurable Mail Rules X \u221a Backend Functionality - Country Management X \u221a - Currency Management X \u221a - Taxation Management X \u221a - Taxation Management X \u221a - Index Management X \u221a - Filter Management X \u221a - Order Management X (partial) \u221a - Voucher Rules \u221a \u221a - Price Rules \u221a \u221a - Order Overview X (partial) \u221a - Quote Overview X \u221a - Order Detail X (partial) \u221a - Quote Detail X \u221a - Order Creation X \u221a - Quote Creation X \u221a Checkout Manager \u221a \u221a Modular\/Componentized X (partial) \u221a Extendable \u221a \u221a To be fair, both Systems have their purpose and you can do the same with both systems. The ecommerce Framework is designed to be very good extendable but you still need to implement a lot of stuff yourself. CoreShop gives you a lot of out-of-the-box features to quickly create rich ecommerce systems.","tags":"","url":"Getting_Started\/Difference_to_ecommerce_Framework.html"},{"title":"Bundles","text":"CoreShop Bundles CoreShop is a set of Bundles that provide different functionality. Each Bundle is supposed to be independent and can be used without the other Bundles. Glued together, they provide a full e-commerce solution. Address Bundle Configuration Bundle Core Bundle Currency Bundle Customer Bundle Fixture Bundle Frontend Bundle Index Bundle Inventory Bundle Locale Bundle Money Bundle Messenger Bundle ! Money Bundle ! Notification Bundle ! Optimistic Entity Lock Bundle ! Order Bundle Payment Bundle Payum Payment Bundle ! Product Bundle Product Quantity Price Rules Bundle Resource Bundle Rule Bundle SEO Bundle Sequence Bundle Shipping Bundle Storage List Bundle Store Bundle Taxation Bundle Theme Bundle Tracking Bundle User Bundle Variant Bundle Wishlist Bundle Workflow Bundle","tags":"","url":"Bundles\/index.html"},{"title":"Address Bundle","text":"CoreShop Address Bundle CoreShop Address Bundle provides a basic set of data for Addressing Information like: Country State Address This Bundle can be used separately, but doesn't provide any detail information how to use it.","tags":"","url":"Bundles\/Address_Bundle.html"},{"title":"Configuration Bundle","text":"CoreShop Configuration Bundle Installation $ composer require coreshop\/configuration-bundle:^3.0 Usage Configuration Component helps you store your configurations in database. $service = new CoreShop\\Component\\Configuration\\Service\\ConfigurationService($doctrineEntityManager, $configRepo, $configFactory); $service-&gt;set('key', 'value'); $service-&gt;get('key');","tags":"","url":"Bundles\/Configuration_Bundle.html"},{"title":"Core Bundle","text":"CoreShop Core Bundle Core Bundle glues all independent CoreShop Bundles into one e-commerce suite and extends certain parts accordingly. This Bundle is not advised to be installed seperately!","tags":"","url":"Bundles\/Core_Bundle.html"},{"title":"Currency Bundle","text":"CoreShop Currency Bundle Currency Bundle provides you with Models for persisting Currencies and resolving Currency Contexts. Symfony Profiler Pimcore Core Extensions Doctrine Mappings Symfony Forms Money Formatter Twig Extensions Currency Formatting Currency Conversion Currency Code to Symbol Installation $ composer require coreshop\/currency-bundle:^3.0 Adding required bundles to kernel You need to enable the bundle inside the kernel &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\CurrencyBundle\\CoreShopCurrencyBundle(), ]); } Updating database schema Run the following command. $ php bin\/console doctrine:schema:update --force Usage This Bundle integrates Currency Component into Symfony and Doctrine The Currency Bundle provides you with basic information needed for Currencies: Currency, Exchange Rates, Conversion and Formatting Doctrine Entities Currency Pimcore UI Currency Exchange Rate How to use? coreshop.global.resource.open('coreshop.currency', 'currency'); coreshop.global.resource.open('coreshop.currency', 'exchange_rate');","tags":"","url":"Bundles\/Currency_Bundle.html"},{"title":"Customer Bundle","text":"CoreShop Customer Bundle Installation $ composer require coreshop\/customer-bundle:^3.0 Adding required bundles to kernel You need to enable the bundle inside the kernel &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\CustomerBundle\\CoreShopCustomerBundle(), ]); } Updating database schema Run the following command. $ php bin\/console doctrine:schema:update --force Install Pimcore Entities $ php bin\/console coreshop:resources:install Learn more about overriding Pimcore Classes here) Usage This Bundle integrates Customer Component into Symfony and Doctrine The Customer Bundle provides you with basic information needed for a Customer: Customer and CustomerGroup The Bundle also introduces an Customer Context, which helps you determine the current Customer. Pimcore Entities Customer (CoreShopCustomer) CustomerGroup (CoreShopCustomerGroup)","tags":"","url":"Bundles\/Customer_Bundle.html"},{"title":"Fixture Bundle","text":"CoreShop Fixture Bundle Fixture Bundle allows us to Install certain data needed for runtime of CoreShop or for the Demo. Installation $ composer require coreshop\/fixture-bundle:^3.0 Adding required bundles to kernel You need to enable the bundle inside the kernel. &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\FixtureBundle\\CoreShopFixtureBundle(), ]); } Updating database schema Run the following command. $ php bin\/console doctrine:schema:update --force Creating a new Fixture Create a new File in your Bundle within the Namespace Fixtures\\Data\\Application for app fixtures and Fixtures\\Data\\Demo for Demo fixtures. The FixtureBundle will automatically recognize your fixtures. &lt;?php namespace CoreShop\\Bundle\\CoreBundle\\Fixtures\\Application; use CoreShop\\Bundle\\FixtureBundle\\Fixture\\VersionedFixtureInterface; use Doctrine\\Common\\DataFixtures\\AbstractFixture; use Doctrine\\Common\\Persistence\\ObjectManager; use Symfony\\Component\\DependencyInjection\\ContainerAwareInterface; use Symfony\\Component\\DependencyInjection\\ContainerInterface; class ConfigurationFixture extends AbstractFixture implements ContainerAwareInterface, VersionedFixtureInterface { \/** * @var ContainerInterface *\/ private $container; \/** * {@inheritdoc} *\/ public function getVersion() { return '2.0'; } \/** * {@inheritdoc} *\/ public function setContainer(ContainerInterface $container = null) { $this-&gt;container = $container; } \/** * {@inheritdoc} *\/ public function load(ObjectManager $manager) { $configurations = [ 'system.guest.checkout' =&gt; true, 'system.category.list.mode' =&gt; 'list', 'system.category.list.per_page' =&gt; [12, 24, 36], 'system.category.list.per_page.default' =&gt; 12, 'system.category.grid.per_page' =&gt; [5, 10, 15, 20, 25], 'system.category.grid.per_page.default' =&gt; 10, 'system.category.variant_mode' =&gt; 'hide', 'system.order.prefix' =&gt; 'O', 'system.order.suffix' =&gt; '', 'system.quote.prefix' =&gt; 'Q', 'system.quote.suffix' =&gt; '', 'system.invoice.prefix' =&gt; 'IN', 'system.invoice.suffix' =&gt; '', 'system.invoice.wkhtml' =&gt; '-T 40mm -B 15mm -L 10mm -R 10mm --header-spacing 5 --footer-spacing 5', 'system.shipment.prefix' =&gt; 'SH', 'system.shipment.suffix' =&gt; '', 'system.shipment.wkhtml' =&gt; '-T 40mm -B 15mm -L 10mm -R 10mm --header-spacing 5 --footer-spacing 5', ]; foreach ($configurations as $key =&gt; $value) { $this-&gt;container-&gt;get('coreshop.configuration.service')-&gt;set($key, $value); } } }","tags":"","url":"Bundles\/Fixture_Bundle.html"},{"title":"Frontend Bundle","text":"CoreShop Frontend Bundle CoreShop FrontendBundle provides some FrontendControllers as well as a default Implementation for the Frontend. This Bundle is not advised to be installed seperately!","tags":"","url":"Bundles\/Frontend_Bundle.html"},{"title":"Index Bundle","text":"CoreShop Index Bundle Installation $ composer require coreshop\/index-bundle:^3.0 Adding required bundles to kernel You need to enable the bundle inside the kernel &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\IndexBundle\\CoreShopIndexBundle(), ]); } Updating database schema Run the following command. $ php bin\/console doctrine:schema:update --force Usage This Bundle integrates Index Component into Symfony and Doctrine The Index Bundle provides you with basic information needed for a Indexing Pimcore Models: Index, Filters and Conditions It also provides you with ListingServices and FilterServices Get Listing from Index How to get a Listing from an Index? $filter = $this-&gt;get('coreshop.repository.filter')-&gt;find(1); \/\/Get Filter by ID 1 $filteredList = $this-&gt;get('coreshop.factory.filter.list')-&gt;createList($filter, $request-&gt;request); $filteredList-&gt;setVariantMode(ListingInterface::VARIANT_MODE_HIDE); $filteredList-&gt;setCategory($category); $this-&gt;get('coreshop.filter.processor')-&gt;processConditions($filter, $filteredList, $request-&gt;query); $filteredList-&gt;load(); Pimcore UI Index Configuration Filter Configuration How to use? coreshop.global.resource.open('coreshop.index', 'index'); coreshop.global.resource.open('coreshop.index', 'filter');","tags":"","url":"Bundles\/Index_Bundle.html"},{"title":"Inventory Bundle","text":"CoreShop Inventory Bundle CoreShop Inventory Bundle provides a Basic implementation to handle Inventory for a Product. This Bundle can be used separately, but doesn't provide any detail information how to use it.","tags":"","url":"Bundles\/Inventory_Bundle.html"},{"title":"Locale Bundle","text":"CoreShop Locale Bundle CoreShop Locale Bundle provides a basic set of data for Locale Information. This Bundle can be used separately, but doesn't provide any detail information how to use it.","tags":"","url":"Bundles\/Locale_Bundle.html"},{"title":"Menu Bundle","text":"CoreShop Menu Bundle Menu Bundle makes it easy creating Pimcore Menus based on permissions. Installation $ composer require coreshop\/menu-bundle:^3.0 Adding required bundles to kernel You need to enable the bundle inside the kernel &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\MenuBundle\\CoreShopMenuBundle(), ]); } Usage Create a new Menu by creating a new Class, let's call it MyMenuBuilder namespace AppBundle\\Menu; use CoreShop\\Bundle\\MenuBundle\\Builder\\MenuBuilderInterface; use Knp\\Menu\\FactoryInterface; use Knp\\Menu\\ItemInterface; class MyMenuBuilder implements MenuBuilderInterface { public function buildMenu(ItemInterface $menuItem, FactoryInterface $factory, string $type) { \/\/Create a new direct sub-menu item $menuItem -&gt;addChild('my-menu-item') -&gt;setLabel('my-menu-item') -&gt;setAttribute('permission', 'my_menu_item') -&gt;setAttribute('iconCls', 'pimcore_icon_delete') ; } } You then need to register your class to the symfony container: app.my_menu: class: AppBundle\\Menu\\MyMenuBuilder tags: - { name: coreshop.menu, type: my_menu, menu: my_menu } Where the menu attribute defines your unique identifier for your menu. You can also register multiple Builders for your Menu with the same menu attribute, this will load them one after another. Now, lets do the ExtJs Javascript part. In your Bundle. I assume you already have a working Bundle for that. In your Bundle.php file, add this file to the jsPaths array: '\/admin\/coreshop\/coreshop.my_menu\/menu.js' Where my_menu here again is your defined identifier. This will load a basic helper file that will build your menu. Now, let's actually build the menu. You should already have a startup.js somehwere in your Bundle. In there, you can instantiate the menu by calling: new coreshop.menu.coreshop.my_menu(); That will build the menu automatically for you. In order now to do something when a menu-item is clicked, you can attach to the event that is fired: pimcore.eventDispatcher.registerTarget('coreshopMenuOpen', new (Class.create({ coreshopMenuOpen: function(type, item) { if (item.id === 'my-menu-item') { alert('My Menu Item has been clicked'); } } })));","tags":"","url":"Bundles\/Menu_Bundle.html"},{"title":"Messenger Bundle","text":"CoreShop Messenger Bundle CoreShop Messenger Bundle provides you with a nice UI to see what Messenger Tasks are queued in which queues: Installation $ composer require coreshop\/messenger-bundle:^3.0 Adding required bundles to kernel You need to enable the bundle inside the kernel. &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\MessengerBundle\\CoreShopMessengerBundle(), ]); }","tags":"","url":"Bundles\/Messenger_Bundle.html"},{"title":"Money Bundle","text":"CoreShop Money Bundle Installation $ composer require coreshop\/money-bundle:^3.0 Adding required bundles to kernel You need to enable the bundle inside the kernel &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\MoneyBundle\\CoreShopMoneyBundle(), ]); } Usage Money Bundle adds a new core-extension to pimcore which allows you to store currency values as integer. You also get a Twig Extension to format money values. {{ value|coreshop_format_money('\u20ac', 'de'); }}","tags":"","url":"Bundles\/Money_Bundle.html"},{"title":"Notification Bundle","text":"CoreShop Notification Bundle CoreShop Notification Bundle handles all communication between CoreShop and the outside world. It provides a basic set of data for Notifications like: Notification Rules Notification Rule Conditions Notification Rule Actions This Bundle can be used separately, but doesn't provide any detail information how to use it. Usage Notifications run async in a Symfony messenger queue: bin\/console messenger:consume coreshop_notification coreshop_index --time-limit=300","tags":"","url":"Bundles\/Notification_Bundle.html"},{"title":"OptimisticEntityLock Bundle","text":"CoreShop Optimistic Entity Lock Bundle The CoreShop Optimistic Entity Lock Bundle is a package for the CoreShop e-commerce framework, based on the Pimcore platform, designed to handle optimistic entity locking. This bundle helps prevent conflicts when multiple users try to edit the same entity concurrently by implementing an optimistic locking strategy. Installation $ composer require optimistic-entity-lock-bundle Adding required bundles to kernel You need to enable the bundle inside the kernel. &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\OptimisticEntityLockBundle\\CoreShopOptimisticEntityLockBundle(), ]); } Usage Your Pimcore DataObject Class needs to implement the Interface CoreShop\\Bundle\\OptimisticEntityLockBundle\\Model\\OptimisticLockedInterface. You can therefore add the field optimisticLockVersion to your Pimcore Class Definition. From now on, everytime the DataObject gets saved, CoreShop compares the Versions and increases it before saving. If the version is different, someone else saved the entity before you and you get a exception.","tags":"","url":"Bundles\/OptimisticEntityLock_Bundle.html"},{"title":"Order Bundle","text":"CoreShop Order Bundle CoreShop Order Bundle provides a basic set of data for Orders. This Bundle can be used separately, but doesn't provide any detail information how to use it.","tags":"","url":"Bundles\/Order_Bundle.html"},{"title":"Payment Bundle","text":"CoreShop Payment Bundle Installation $ composer require coreshop\/payment-bundle:^3.0 Adding required bundles to kernel You need to enable the bundle inside the kernel &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\PaymentBundle\\CoreShopPaymentBundle(), ]); } Updating database schema Run the following command. $ php bin\/console doctrine:schema:update --force Usage This Bundle integrates Payment Component into Symfony and Doctrine The Payment Bundle provides you with basic information needed for payment: Payment The Bundle also introduces an Address Formatter, which formats addresses in country based formats. Doctrine Entities Payment Pimcore UI Payment Provider How to use? coreshop.global.resource.open('coreshop.payment', 'payment_provider');","tags":"","url":"Bundles\/Payment_Bundle.html"},{"title":"Payum Bundle","text":"CoreShop Payum Bundle Handles the Payum Integration with CoreShop. This Bundle requires the Core and can only be used in the full installation. This Bundle is not advised to be installed seperately!","tags":"","url":"Bundles\/Payum_Bundle.html"},{"title":"PayumPayment Bundle","text":"CoreShop Payum Payment Bundle Integrates CoreShop Payment Bundle with Payum.","tags":"","url":"Bundles\/PayumPayment_Bundle.html"},{"title":"Pimcore Bundle","text":"CoreShop Pimcore Bundle Installation $ composer require coreshop\/pimcore-bundle:^3.0 Activating Bundle You need to enable the bundle inside the kernel or with the Pimcore Extension Manager. &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\PimcoreBundle\\CoreShopPimcoreBundle() ]); } Usage The CoreShopPimcoreBundle integrates the CoreShop Pimcore Component into Symfony automatically registers a lot of services for you. JS\/CSS Resource Loading With Pimcore, every bundle needs to take care about loading static assets themselve. PimcoreBundle helps you out here, follow these steps to use it: Create a DependencyInjection Extension class like: &lt;?php namespace AppBundle\\DependencyInjection; use CoreShop\\Bundle\\ResourceBundle\\DependencyInjection\\Extension\\AbstractModelExtension; use Symfony\\Component\\Config\\FileLocator; use Symfony\\Component\\DependencyInjection\\ContainerBuilder; use Symfony\\Component\\DependencyInjection\\Loader\\YamlFileLoader; class AppExtension extends AbstractModelExtension { public function load(array $config, ContainerBuilder $container) { $config = $this-&gt;processConfiguration($this-&gt;getConfiguration([], $container), $config); $loader = new YamlFileLoader($container, new FileLocator(__DIR__.'\/..\/Resources\/config')); $loader-&gt;load('services.yml'); $this-&gt;registerPimcoreResources('coreshop', $config['pimcore_admin'], $container); } } Create a DependencyInjection Configuration class like: &lt;?php namespace AppBundle\\DependencyInjection; use Symfony\\Component\\Config\\Definition\\Builder\\ArrayNodeDefinition; use Symfony\\Component\\Config\\Definition\\Builder\\TreeBuilder; use Symfony\\Component\\Config\\Definition\\ConfigurationInterface; final class Configuration implements ConfigurationInterface { \/** * {@inheritdoc} *\/ public function getConfigTreeBuilder() { $treeBuilder = new TreeBuilder(); $rootNode = $treeBuilder-&gt;root('app'); $this-&gt;addPimcoreResourcesSection($rootNode); return $treeBuilder; } \/** * @param ArrayNodeDefinition $node *\/ private function addPimcoreResourcesSection(ArrayNodeDefinition $node) { $node-&gt;children() -&gt;arrayNode('pimcore_admin') -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;arrayNode('js') -&gt;addDefaultsIfNotSet() -&gt;ignoreExtraKeys(false) -&gt;children() -&gt;scalarNode('test')-&gt;defaultValue('\/bundles\/app\/pimcore\/js\/test.js')-&gt;end() -&gt;end() -&gt;end() -&gt;arrayNode('css') -&gt;addDefaultsIfNotSet() -&gt;ignoreExtraKeys(false) -&gt;children() -&gt;scalarNode('test')-&gt;defaultValue('\/bundles\/app\/pimcore\/css\/pimcore.css')-&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end(); } } That's it, PimcoreBundle now takes care about loading your resources and also bundles them in non DEV-Mode. DataObject Extensions Serialized Data This extension allows you to store SerializedData inside a Pimcore DataObject. Slug Pimcore comes with quite useful objects slugs. But it doesn't come with a Slug Generator. CoreShop for the rescue. In Order to use it, your class needs to implement CoreShop\\Component\\Pimcore\\Slug\\SluggableInterface and CoreShop automatically generates slugs for you. Extensions \/ Influence the slug generation If you want to change the generated slug or prefix it, you can use the CoreShop\\Component\\Pimcore\\Event\\SlugGenerationEvent Event. &lt;?php declare(strict_types=1); namespace App\\EventListener; use CoreShop\\Component\\Pimcore\\Event\\SlugGenerationEvent; use Pimcore\\Model\\DataObject\\PressRelease; use Pimcore\\Model\\Document; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; final class SlugEventListener implements EventSubscriberInterface { public static function getSubscribedEvents() { return [ SlugGenerationEvent::class =&gt; 'onGenerate', ]; } public function onGenerate(SlugGenerationEvent $event): void { $event-&gt;setSlug($event-&gt;getSlug() . '-bar'); } } Data Object Features Class Converter and Data Migrate Class converter is a small utility, which lets you migrate all Data from one class to another. Usage: &lt;?php use CoreShop\\Component\\Pimcore\\Migrate; $currentClassName = 'Product'; $newClassName = 'NewProduct'; $options = [ 'delete_existing_class' =&gt; true, 'parentClass' =&gt; 'AppBundle\\Model\\MyProduct' ]; \/\/Copies $currentClassName Definition to $newClassName \/\/$options can overwrite some properties like parentClass Migrate::migrateClass($currentClassName, $newClassName, $options); \/\/This function migrates all data from $currentClassName to $newClassName \/\/It uses SQL Commands to increase performance of migration Migrate::migrateData($currentClassName, $newClassName); Class Installer Class Installer helps you importing Classes\/FieldCollections\/ObjectBricks into Pimcore based of a JSON Definition: use CoreShop\\Component\\Pimcore\\ClassInstaller; $installer = new ClassInstaller(); \/\/ For Bricks use $installer-&gt;createBrick($pathToJson, $brickName); \/\/ For Classes use $installer-&gt;createClass($pathToJson, $className, $updateExistingClass); \/\/ For FieldCollections use $installer-&gt;createFieldCollection($pathToJson, $fcName); Class\/Brick\/Field Collection Updater Definition Updaters help you in migrating your Pimcore Class\/Bricks or Field Collection Definitions to be properly migrated from Release to Release. To update a Pimcore class use it like this: use CoreShop\\Component\\Pimcore\\DataObject\\ClassUpdate; $classUpdater = new ClassUpdate('Product'); \/\/Your JSON Definition from Pimcore $payment = [ 'fieldtype' =&gt; 'coreShopSerializedData', 'phpdocType' =&gt; 'array', 'allowedTypes' =&gt; [ ], 'maxItems' =&gt; 1, 'name' =&gt; 'paymentSettings', 'title' =&gt; 'Payment Settings', 'tooltip' =&gt; '', 'mandatory' =&gt; false, 'noteditable' =&gt; true, 'index' =&gt; false, 'locked' =&gt; null, 'style' =&gt; '', 'permissions' =&gt; null, 'datatype' =&gt; 'data', 'columnType' =&gt; null, 'queryColumnType' =&gt; null, 'relationType' =&gt; false, 'invisible' =&gt; false, 'visibleGridView' =&gt; false, 'visibleSearch' =&gt; false, ]; \/\/Check if field exists if (!$classUpdater-&gt;hasField('paymentSettings')) { \/\/If not insert field after a specific field and save the definition $classUpdater-&gt;insertFieldAfter('paymentProvider', $payment); $classUpdater-&gt;save(); } Thats it, the same works for FieldCollections with the class CoreShop\\Component\\Pimcore\\DataObject\\FieldCollectionDefinitionUpdate and for Bricks with the class CoreShop\\Component\\Pimcore\\DataObject\\BrickDefinitionUpdate Inheritance Helper Inhertiance Helper is a small little but very useful helper class to enable Pimcore inheritance only with a closure function like this: use CoreShop\\Component\\Pimcore\\DataObject\\InheritanceHelper; $inheritedValue = InheritanceHelper::useInheritedValues(function() use($object) { return $object-&gt;getValueInherited(); }, true); Version Helper Version Helper is a small little but very useful helper class to disabling or enablind Pimcore Versioning. use CoreShop\\Component\\Pimcore\\DataObject\\VersionHelper; VersionHelper::useVersioning(function() use($object) { \/\/Object will be saved without creating a new Version $object-&gt;save(); }, false); Unpublished Helper Unpublsihed Helper is a small little but very useful helper class to get unpublished objects in Pimcore Frontend. use CoreShop\\Component\\Pimcore\\DataObject\\UnpublishedHelper; $allProducts = UnpublishedHelper::hideUnpublished(function() use($object) { \/\/Will return all products, even the unpbulished ones return $object-&gt;getProducts(); }, false); Expression Language Features CoreShop adds some features to the Symfony Expression language like: PimcoreLanguageProvider: to get Pimcore Objects, Assets or Documents inside a Expression Language Query Migration Features Pimcore Shared Translations Helps you to install new Shared Translations during Migration: use CoreShop\\Component\\Pimcore\\Migration\\SharedTranslation; SharedTranslation::add('key', 'en', 'value');","tags":"","url":"Bundles\/Pimcore_Bundle.html"},{"title":"Product Bundle","text":"CoreShop Product Bundle CoreShop Product Bundle is responsible for the Product Management. This Bundle can be used separately, but doesn't provide any detail information how to use it.","tags":"","url":"Bundles\/Product_Bundle.html"},{"title":"ProductQuantityPriceRules Bundle","text":"CoreShop Product Quantity Price Rules Bundle This Bundle implements the Quantity Price Rules for CoreShop. This Bundle can be used separately, but doesn't provide any detail information how to use it.","tags":"","url":"Bundles\/ProductQuantityPriceRules_Bundle.html"},{"title":"Resource Bundle","text":"CoreShop Resource Bundle Resource Bundle is the Heart of CoreShops Model. It handles saving\/deleting\/updating\/creating of CoreShop Models. It handles Doctrine ORM Mappings and Translations. As well as Routing, Event Dispatching, Serialization and CRUD. Resource Bundle also takes care about installation of Pimcore Class Definitions, Object Brick Definitions, Field Collection Definitions, Static Routes and SQL. You can use Resource Bundle as base for all your Custom Pimcore Entities. Installation $ composer require coreshop\/resource-bundle:^3.0 Adding required bundles to kernel You need to enable the bundle inside the kernel &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\JMS\\SerializerBundle\\JMSSerializerBundle(), new \\CoreShop\\Bundle\\ResourceBundle\\CoreShopResourceBundle(), new \\Doctrine\\Bundle\\DoctrineCacheBundle\\DoctrineCacheBundle(), new \\Stof\\DoctrineExtensionsBundle\\StofDoctrineExtensionsBundle() ]); }","tags":"","url":"Bundles\/Resource_Bundle\/index.html"},{"title":"CustomEntities","text":"Adding a new custom entity Create Translatable Entity First of all, we need to create our Entity Class. In this case, we create a Translatable Entity. &lt;?php \/\/AppBundle\/Model\/CustomEntityInterface.php interface CustomEntityInterface extends ResourceInterface, TranslatableInterface { public function getName($language = null); public function setName($name, $language = null); } &lt;?php \/\/AppBundle\/Model\/CustomEntity.php class CustomEntity implements CustomEntityInterface { use TranslatableTrait { __construct as private initializeTranslationsCollection; } protected $id; protected $name; public function __construct() { $this-&gt;initializeTranslationsCollection(); } public function getId() { return $this-&gt;id; } public function getName($language = null) { return $this-&gt;getTranslation($language)-&gt;getName(); } public function setName($name, $language = null) { $this-&gt;getTranslation($language, false)-&gt;setName($name); return $this; } protected function createTranslation() { return new CustomEntityTranslation(); } } Since our Entity is Translatable, we need to add our Translation Entity as well. &lt;?php \/\/AppBundle\/Model\/CustomEntityTranslationInterface.php interface CustomEntityTranslationInterface extends ResourceInterface, TimestampableInterface { \/** * @return string *\/ public function getName(); \/** * @param string $name *\/ public function setName($name); } &lt;?php \/\/AppBundle\/Model\/CustomEntityTranslation.php class CustomEntityTranslation extends AbstractTranslation implements CustomEntityTranslationInterface { protected $id; protected $name; public function getId() { return $this-&gt;id; } public function getName() { return $this-&gt;name; } public function setName($name) { $this-&gt;name = $name; } } Create Doctrine Configuration # AppBundle\/Resources\/config\/doctrine\/model\/CustomEntity.orm.yml AppBundle\\Model\\CustomEntity: type: mappedSuperclass table: app_custom_entity fields: id: type: integer column: id id: true generator: strategy: AUTO Our Translation Doctrine definition: # AppBundle\/Resources\/config\/doctrine\/model\/CustomEntityTranslation.orm.yml AppBundle\\Model\\CustomEntityTranslation: type: mappedSuperclass table: app_custom_entity_translation fields: id: type: integer column: id id: true generator: strategy: AUTO name: type: string column: name Create DI Configuration &lt;?php \/\/AppBundle\/DependencyInjection\/Configuration.php namespace CoreShop\\Bundle\\AddressBundle\\DependencyInjection; final class Configuration implements ConfigurationInterface { \/** * {@inheritdoc} *\/ public function getConfigTreeBuilder() { $treeBuilder = new TreeBuilder(); $rootNode = $treeBuilder-&gt;root('app'); $rootNode -&gt;children() -&gt;scalarNode('driver')-&gt;defaultValue(CoreShopResourceBundle::DRIVER_DOCTRINE_ORM)-&gt;end() -&gt;end() ; $this-&gt;addModelsSection($rootNode); return $treeBuilder; } \/** * @param ArrayNodeDefinition $node *\/ private function addModelsSection(ArrayNodeDefinition $node) { $node -&gt;children() -&gt;arrayNode('resources') -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;arrayNode('custom_entity') -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;variableNode('options')-&gt;end() -&gt;scalarNode('permission')-&gt;defaultValue('custom_entity')-&gt;cannotBeOverwritten()-&gt;end() -&gt;arrayNode('classes') -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;scalarNode('model')-&gt;defaultValue(CustomEntity::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('interface')-&gt;defaultValue(CustomEntityInterface::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('admin_controller')-&gt;defaultValue(ResourceController::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('factory')-&gt;defaultValue(TranslatableFactory::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('repository')-&gt;defaultValue(CustomEntityRepository::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('form')-&gt;defaultValue(CustomEntityType::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;end() -&gt;end() -&gt;arrayNode('translation') -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;variableNode('options')-&gt;end() -&gt;arrayNode('classes') -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;scalarNode('model')-&gt;defaultValue(CustomEntityTranslation::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('interface')-&gt;defaultValue(CustomEntityTranslationInterface::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('controller')-&gt;defaultValue(ResourceController::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('repository')-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('factory')-&gt;defaultValue(Factory::class)-&gt;end() -&gt;scalarNode('form')-&gt;defaultValue(CustomEntityTranslationType::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() ; } } &lt;?php \/\/AppBundle\/DependencyInjection\/AppExtension.php final class AppExtension extends AbstractModelExtension { \/** * {@inheritdoc} *\/ public function load(array $config, ContainerBuilder $container) { $config = $this-&gt;processConfiguration($this-&gt;getConfiguration([], $container), $config); \/\/'app' is the application name $this-&gt;registerResources('app', $config['driver'], $config['resources'], $container); } } &lt;?php \/\/AppBundle\/DependencyInjection\/AppExtension.php final class AppBundle extends AbstractResourceBundle { public function getSupportedDrivers() { return [ CoreShopResourceBundle::DRIVER_DOCTRINE_ORM, ]; } protected function getModelNamespace() { return 'AppBundle\\Model'; } } Create Serialization Definition if you want to serialize your Entity # AppBundle\/Resources\/config\/serializer\/Model.CustomEntity.yml AppBundle\\Model\\CustomEntity: exclusion_policy: ALL xml_root_name: custom_entity properties: id: expose: true type: integer groups: [List, Detailed] translations: expose: true type: array groups: [Detailed] virtual_properties: getName: serialized_name: name groups: [List, Detailed] # AppBundle\/Resources\/config\/serializer\/Model.CustomEntityTranslation.yml AppBundle\\Model\\CustomEntityTranslation: exclusion_policy: ALL xml_root_name: custom_entity_translation properties: name: expose: true type: string groups: [Detailed] Create Routes to ResourceController # AppBundle\/Resources\/config\/pimcore\/routing.yml app_custom_entity: type: coreshop.resources resource: | alias: app.custom_entity This will create all CRUD routes: (app is the application name specified in AppExtension.php) GET: \/admin\/app\/custom_entity\/list GET: \/admin\/app\/custom_entity\/get POST: \/admin\/app\/custom_entity\/add POST: \/admin\/app\/custom_entity\/save DELETE: \/admin\/app\/custom_entity\/delete","tags":"","url":"Bundles\/Resource_Bundle\/CustomEntities.html"},{"title":"PimcoreEntities","text":"Adding a new Pimcore Entity with automated installation Add a new Pimcore Class in Pimcore. Add a Parent Class to your Pimcore Entity Export Class Definition to AppBundle\/Resources\/install\/pimcore\/classes\/PimcoreEntity.json Create Parent Class &lt;?php \/\/AppBundle\/Model\/PimcoreEntityInterface.php interface PimcoreEntityInterface extends ResourceInterface public function getName($language = null); public function setName($name, $language = null); } &lt;?php \/\/AppBundle\/Model\/PimcoreEntity.php class PimcoreEntity extends AbstractPimcoreModel implements PimcoreEntityInterface, PimcoreModelInterface { public function getName($language = null) { throw new ImplementedByPimcoreException(__CLASS__, __METHOD__); } public function setName($name, $language = null) { throw new ImplementedByPimcoreException(__CLASS__, __METHOD__); } } Create Dependency Injection Configuration &lt;?php \/\/AppBundle\/DependencyInjection\/Configuration.php namespace AppBundle\\DependencyInjection; final class Configuration implements ConfigurationInterface { public function getConfigTreeBuilder() { $treeBuilder = new TreeBuilder(); $rootNode = $treeBuilder-&gt;root('app_custom'); $this-&gt;addModelsSection($rootNode); return $treeBuilder; } private function addModelsSection(ArrayNodeDefinition $node) { $node -&gt;children() -&gt;arrayNode('pimcore') -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;arrayNode('pimcore_entity') -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;variableNode('PimcoreEntity')-&gt;end() -&gt;arrayNode('options') -&gt;scalarNode('path')-&gt;defaultValue('path\/within\/pimcore')-&gt;end() -&gt;scalarNode('permission')-&gt;defaultValue('pimcore_entity')-&gt;cannotBeOverwritten()-&gt;end() -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;scalarNode('model')-&gt;defaultValue('Pimcore\\Model\\Object\\PimcoreEntity')-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('interface')-&gt;defaultValue(PimcoreEntity::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('factory')-&gt;defaultValue(PimcoreFactory::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('repository')-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('admin_controller')-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('install_file')-&gt;defaultValue('@AppBundle\/Resources\/install\/pimcore\/classes\/PimcoreEntity.json')-&gt;end() -&gt;scalarNode('type')-&gt;defaultValue(CoreShopResourceBundle::PIMCORE_MODEL_TYPE_OBJECT)-&gt;cannotBeOverwritten(true)-&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() ; } } &lt;?php \/\/AppBundle\/DependencyInjection\/AppBundleExtension.php namespace AppBundle\\DependencyInjection; final class AppBundleExtension extends AbstractModelExtension { public function load(array $config, ContainerBuilder $container) { $this-&gt;registerPimcoreModels('app', $config['pimcore'], $container); } } Use your Pimcore Entity You can either use Pimcore Listing Classes like: $list = new Pimcore\\Model\\Object\\PimcoreEntity\\Listing(); or use automated generated Factory\/Repository Classes $pimcoreEntityObject = $container-&gt;get('app.repository.pimcore_entity')-&gt;findBy($id); $list = $container-&gt;get('app.repository.pimcore_entity')-&gt;getList();","tags":"","url":"Bundles\/Resource_Bundle\/PimcoreEntities.html"},{"title":"Installation","text":"Adding new files that needs to be installed Resource Bundles takes care about installing your resources. It can handle following types: - Object Classes - Field Collection Classes - Objectbrick Classes - Routes - Permissions - SQL Files Object Classes, Field Collections and Objectbrick Classes To install object classes, you need to configure your classes inside your Bundle and register them to Resource Bundle. (as described here) Routes, SQL and Permissions To install routes, permissions or execute sql files, configure them in your Bundle likes this: &lt;?php namespace AppBundle\\DependencyInjection; final class Configuration implements ConfigurationInterface { \/** * {@inheritdoc} *\/ public function getConfigTreeBuilder() { $treeBuilder = new TreeBuilder(); $rootNode = $treeBuilder-&gt;root('AppBundle'); $this-&gt;addPimcoreResourcesSection($rootNode); return $treeBuilder; } private function addPimcoreResourcesSection(ArrayNodeDefinition $node) { $node-&gt;children() -&gt;arrayNode('pimcore_admin') -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;arrayNode('install') -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;scalarNode('routes')-&gt;defaultValue(['@AppBundle\/Resources\/install\/pimcore\/routes.yml'])-&gt;end() -&gt;scalarNode('sql')-&gt;defaultValue(['@AppBundle\/Resources\/install\/pimcore\/data.sql'])-&gt;end() -&gt;end() -&gt;end() -&gt;scalarNode('permissions') -&gt;cannotBeOverwritten() -&gt;defaultValue(['name_of_permission']) -&gt;end() -&gt;end() -&gt;end() -&gt;end(); } } Routes Example File yeah_route: pattern: &quot;\/(\\\\w+)\\\\\/yeah-route\/&quot; reverse: &quot;\/%_locale\/yeah\\-route&quot; module: AppBundle controller: &quot;@app.frontend.controller.controller&quot; action: doSomething variables: _locale priority: 2","tags":"","url":"Bundles\/Resource_Bundle\/Installation.html"},{"title":"Rule Bundle","text":"CoreShop Rule Bundle CoreShop Rule Bundle is the base Bundle for all Rule Based Systems in CoreShop. It provides a basic set of data for Rules like: Rule Conditions Rule Actions This Bundle can be used separately, but doesn't provide any detail information how to use it.","tags":"","url":"Bundles\/Rule_Bundle.html"},{"title":"SEO Bundle","text":"CoreShop SEO Bundle Installation $ composer require coreshop\/seo-bundle:^3.0 Activating Bundle You need to enable the bundle inside the kernel or with the Pimcore Extension Manager. &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\SEOBundle\\CoreShopSEOBundle() ]); } Usage The SEO Bundle provides you with services to make SEO more manageable. It depends on Pimcore's HeadLink and HeadMeta Helper. There are multiple ways of making use of this bundle: Implement SEO interfaces provided with this bundle Implement Custom Extractors and add them to the SEOMetadata Model To update the SEO Information, you need to use the service coreshop.seo.presentation: \/\/From a Controller $this-&gt;get('coreshop.seo.presentation')-&gt;updateSeoMetadata($object); Implement SEO Interfaces SEO Bundle comes with 3 SEO Aware interfaces you can take advantage of: CoreShop\\Component\\SEO\\Model\\SEOAwareInterface for meta-title and meta-description CoreShop\\Component\\SEO\\Model\\SEOImageAwareInterface for og-image attribute CoreShop\\Component\\SEO\\Model\\SEOImageAwareInterface for og-title, og-type and pg-description attribute Implement SEO Extractors To add a new Extractor, you need to implement the interface CoreShop\\Component\\SEO\\Extractor\\ExtractorInterface and register your class with the tag coreshop.seo.extractor: Example Let's implement a custom extractor for our Product class with a Video. &lt;?php \/\/src\/AppBundle\/SEO\/Extractor\/ProductVideoExtractor.php namespace AppBundle\\SEO\\Extractor; use Pimcore\\Model\\DataObject\\Product; use Pimcore\\Tool; final class ProductVideoExtractor implements ExtractorInterface { \/** * {@inheritdoc} *\/ public function supports($object) { return $object instanceof Product &amp;&amp; $object-&gt;getVideoUrl(); } \/** * {@inheritdoc} *\/ public function updateMetadata($object, SEOMetadataInterface $seoMetadata) { \/** * @var $object Product *\/ $seoMetadata-&gt;addExtraProperty('og:video', Tool::getHostUrl() . $object-&gt;getVideoUrl()); } } Now we need to register the service # src\/AppBundle\/Resources\/config\/services.yml services: AppBundle\\SEO\\Extractor: tags: - { name: coreshop.seo.extractor, type: product_video }","tags":"","url":"Bundles\/SEO_Bundle.html"},{"title":"Sequence Bundle","text":"CoreShop Sequence Bundle Installation $ composer require coreshop\/sequence-bundle:^3.0 Adding required bundles to kernel You need to enable the bundle inside the kernel &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\SequenceBundle\\CoreShopSequenceBundle(), ]); } Updating database schema Run the following command. $ php bin\/console doctrine:schema:update --force Usage This Bundle integrates Sequence Component into Symfony and Doctrine The sequence Bundle provides you with basic information needed for sequence generation. Doctrine Entities Sequence Get a new Sequence $container-&gt;get('coreshop.sequence.generator')-&gt;getNextSequenceForType('my_sequence');","tags":"","url":"Bundles\/Sequence_Bundle.html"},{"title":"Shipping Bundle","text":"CoreShop Shipping Bundle CoreShop Shipping Bundle is responsible for Shipping Calculations. This Bundle can be used separately, but doesn't provide any detail information how to use it.","tags":"","url":"Bundles\/Shipping_Bundle.html"},{"title":"StorageList Bundle","text":"CoreShop Storage List Bundle Storage List Component helps you with Lists\/Collections of Objects like a Cart, Wishlist or Compare List. Usage To use it you need to have 3 models: a Storage List: the collection (CoreShop\\Component\\StorageList\\Model\\StorageListInterface) a Storage Item: the item within the collection which could store additional information (eg. prices for a cart) (CoreShop\\Component\\StorageList\\Model\\StorageListItemInterface) a Storage Product: the actual product (eg. object) being stored inside the Item. (CoreShop\\Component\\StorageList\\Model\\StorageListProductInterface) The component already provides you with a basic implementation of Storage List and Storage Item. You need to implement the StorageListProduct yourself. To now mutate lists, the component gives you a Storage List Modifier, which takes care about creating and persisting the List. Basic usage, Wishist example For now, lets create a very basic Session based Wishlist: We need to have following things: A Factory class for the Wishlist A Factory class for the Wishlist Item A StorageListManager to get the current list (more like a repository actually) A StoreListModifier CoreShop gives you Basic classes for these 4 things, we just need to instantiate them: use Symfony\\Component\\HttpFoundation\\Session\\Session; use CoreShop\\Component\\StorageList\\Model\\StorageList; use CoreShop\\Component\\StorageList\\Model\\StorageListItem; use CoreShop\\Component\\Resource\\Factory\\Factory; use CoreShop\\Component\\StorageList\\SessionStorageManager; use CoreShop\\Component\\StorageList\\SessionStorageListModifier; $session = new Session(); $session-&gt;start(); $wishlistFactory = new Factory(StorageList::class); $wishlistItemFactory = new Factory(StorageListItem::class); $wishlistManager = new SessionStorageManager($session, 'wishlist', $wishlistFactory); $wishlistModifier = new SessionStorageListModifier($wishlistItemFactory, $wishlistManager); \/\/Now we can start putting data into our List $list = $wishlistManager-&gt;getStorageList(); \/\/Fetch our Product which implements CoreShop\\Component\\StorageList\\Model\\StorageListProductInterface $product = $productRepository-&gt;find(1); $listItem = $wishlistItemFactory-&gt;createNew(); $listItem-&gt;setProduct($product); $listItem-&gt;setQuantity($quantity); \/\/Lets add our Product $wishlistModifier-&gt;addToList($list, $listItem); \/\/If we now want to remove it, we can either use the $listItem, or the Product \/\/To do that with our item, we simply call $wishlistModifier-&gt;removeFromList($list, $listItem);","tags":"","url":"Bundles\/StorageList_Bundle.html"},{"title":"Store Bundle","text":"CoreShop Store Bundle CoreShop Store Bundle provides the abstraction of a Pimcore Website and a CoreShop Store. It handles the configuration for base-currencies and themes. This Bundle can be used separately, but doesn't provide any detail information how to use it.","tags":"","url":"Bundles\/Store_Bundle.html"},{"title":"Taxation Bundle","text":"CoreShop Taxation Bundle CoreShop Taxation Bundle is responsible for Tax Calculations. This Bundle can be used separately, but doesn't provide any detail information how to use it.","tags":"","url":"Bundles\/Taxation_Bundle.html"},{"title":"Theme Bundle","text":"CoreShop Theme Bundle CoreShop Theme Bundle provides you with a flexible and extensible way of having multiple themes in a Pimcore installation. Installation $ composer require coreshop\/theme-bundle:^3.0 Adding required bundles to kernel You need to enable the bundle inside the kernel. &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\ThemeBundle\\CoreShopThemeBundle(), ]); } Configuration Per Default, no Theme Resolver is enabled, you can enable on or multiples like: core_shop_theme: default_resolvers: pimcore_site: true pimcore_document_property: true Pimcore Site Resolves the Theme based on the Key of the Root Document of a Pimcore Site. So if the Site's Root Document is called &quot;demo&quot; it tries to find a theme called the same. Pimcore Document Property Resolves the Theme based on a Document Property of the Site. The Property is called &quot;theme&quot;. Custom Resolvers You can also add custom resolvers like: &lt;?php declare(strict_types=1); namespace App\\Theme; use CoreShop\\Bundle\\ThemeBundle\\Service\\ThemeNotResolvedException; use CoreShop\\Bundle\\ThemeBundle\\Service\\ThemeResolverInterface; use CoreShop\\Component\\Store\\Context\\StoreNotFoundException; final class CustomThemeResolver implements ThemeResolverInterface { public function resolveTheme(): string { if(rand() === 1) { \/\/ if you cannot resolve the theme, throw an exception throw new ThemeNotResolvedException(); } return &quot;custom\/custom&quot;; } } You also need to Register the Theme Resolver: services: App\\Theme\\CustomThemeResolver: tags: - { name: coreshop.theme.resolver, type: custom, priority: 20 }","tags":"","url":"Bundles\/Theme_Bundle.html"},{"title":"Tracking Bundle","text":"CoreShop Tracking Bundle Installation $ composer require coreshop\/tracking-bundle:^3.0 Usage See here for more.","tags":"","url":"Bundles\/Tracking_Bundle.html"},{"title":"User Bundle","text":"CoreShop User Bundle CoreShop User Bundle is responsible for the User Management. This Bundle can be used separately, but doesn't provide any detail information how to use it.","tags":"","url":"Bundles\/User_Bundle.html"},{"title":"Variant Bundle","text":"CoreShop Variant Bundle CoreShop Variant Bundle allows you to manage different Variants of a Product. Installation composer require coreshop\/variant-bundle Adding required bundles to kernel You need to enable the bundle inside the kernel. &lt;?php \/\/ app\/AppKernel.php public function registerBundlesToCollection(BundleCollection $collection) { $collection-&gt;addBundles([ new \\CoreShop\\Bundle\\VariantBundle\\CoreShopVariantBundle(), ]); } Abstract Pimcore already supports variants. But it doesn't define what a Variant is, or how a variant differs from the Parent Product or other Variants. In classical e-commerce scenarios, you usually have different Variation Types like Size and Color with different Values like XL or Red. CoreShop describes these two types of entities as Group (CoreShop\\Component\\Variant\\Model\\AttributeGroupInterface) and Value (CoreShop\\Component\\Variant\\Model\\AttributeValueInterface The &quot;Product&quot; itself than is a sort-of abstract entity that is used to define what Attribute Groups are allowed. The Pimcore Variants then, need to have the values of thse Groups filled. Example: AttributeGroup Color -AttributeValue Red -AttributeValue Blue product (defines allowed groups for color) variant-red (defines the AttributeValue Red in attributes) variant-blue (defines the AttributeValue Blue in attributes) Usage CoreShop Variant Bundle does NOT come with a Installer for certain Resources it requires. That is on purpose and you need to manually install what you need. Per Default, it comes with 3 different Classes: CoreShopAttributeGroup CoreShopAttributeColor CoreShopAttributeValue Whereas Color and Value are two Value types and Group is a Group type. You can manually import the classes from this dir vendor\/coreshop\/variant-bundle\/Resources\/install\/pimcore\/classes To create a &quot;Product&quot; Class, you need to implement the interface CoreShop\\Component\\Variant\\Model\\ProductVariantAwareInterface. The Class requires you to have these fields: attributes - ManyToManyObjectRelation for CoreShopAttributeColor\/CoreShopAttributeValue allowedAttributeGroups - ManyToManyObjectRelation for CoreShopAttributeGroup mainVariant - ManyToOneRelation for Product (eg. your Class where you implemented the interface)","tags":"","url":"Bundles\/Variant_Bundle.html"},{"title":"Wishlist Bundle","text":"CoreShop Order Bundle CoreShop Order Wishlist provides a basic set of data for Wishlists. It is based on StorageList Bundle and shows how that can be integrated into a Pimcore Project. This Bundle can be used separately, but doesn't provide any detail information how to use it.","tags":"","url":"Bundles\/Wishlist_Bundle.html"},{"title":"Workflow Bundle","text":"CoreShop Workflow Bundle CoreShop Workflow Bundle is a extension of Symfony Workflow and adds some configuration features to it. This Bundle can be used separately, but doesn't provide any detail information how to use it.","tags":"","url":"Bundles\/Workflow_Bundle.html"},{"title":"User Documentation","text":"User Documentation This section provides a quick getting started tutorial for CoreShop and covers the following topics: Stores Settings Price Rules Cart Price Rules Product Price Rules Specific Product Price Vouchers Available Actions Available Conditions Localization Countries States Zones Taxes Taxes TaxRules Shipping Carriers Shipping Rules Cart Order Orders Order Detail Order Workflow Order Comments Catalog Products Product Variants Categories Inventory GEO IP Reports Sales Cart\/Order Conversion Abandoned Carts Products Categories Customers Carrier Distribution Payment Distribution Vouchers Automation","tags":"","url":"User_Documentation\/index.html"},{"title":"Stores","text":"CoreShop Stores Every CoreShop Installation is bounded to a default Store. By default a store is connected with a pimcore Site. Domain based Store This is CoreShops default behaviour. One store for your default page, which is also your default store. If you have multiple Domains it's possible to add a store to each domain. Tip: Learn more about pimcore multi sites: Pimcore Sites Custom Store Locator Sometimes you have just one site installation but you want do use different Stores. Example: \/de-at should use a austrian store and \/de-de a german one. For that you need to build a custom store locator to do so, checkout the dev section to find out how this can be achieved. Configure CoreShop Stores Open CoreShop Menu -&gt; &quot;Stores&quot;. There should be already a default store, connected to your default (main-domain) site. To create a new store, click on the &quot;Add&quot; button. Proceed wih configuring your new store. Examples Stores can be used in many ways, checkout the examples to find out which solution suits you most. Example 1: Global Store Use a Store to handle multiple currencies, countries and tax calculations. Depending on your product and price strategy, it's possible to use it within one store. Example 2: Country Store Use a Store for each Country. This allows you to restrict your shop within a country context.","tags":"","url":"User_Documentation\/Stores.html"},{"title":"Settings","text":"CoreShop's Settings are divided into each &quot;sub&quot;-shop and some system settings. Shop-Settings Settings can be different for each Store. Base Catalog-Mode: With catalog-mode enabled, the cart and checkout are disabled. Products can only be viewed. Guest-Checkout: Enables or disables guest-checkout feature Customer Service Customer Email Document: Email document used to send customer messages Customer Re Email Document: Email document used to send customer reply messages Contact Email Document: Email document used to send contact messages Contact Sales: Default contact used for sales messages Contact Technology: Default contact used for technology messages Stock Default Stock Behaviour: Describes the default stock behaviour for products Tax Validate VAT: Describes if the VAT-Number for European Countries should be validated Disable VAT for Base Country: Disable VAT-Free Shopping for Customers, with valid Vat-Number, in Base Country Taxation Address: Describes witch address is responsibly for taxation Prices Prices are gross prices: Determines if entered prices in CoreShop are with or without tax included. Shipping Free Shipping starts at weight: Describes free shipping at weight. It's also much faster using this than price-rules Free Shipping starts at Currency: Describes free shipping at cart value. It's also much faster using this than price-rules Carrier Sort: Describes how the Carriers should be sorted Product Default Image: Defines an default image for products if no image is available. Number of days as new: Defines the time of days a product is marked as new. Category Default Image: Defines an default image for categories if no image is available. Invoice Create Invoice for Orders: Defines if invoices are going to be created on an paid order. Prefix: Prefix string for Order and Invoice numbers Suffix: Suffix string for Orders and Invoice numbers. WKHTMLTOPDF Parameters: Parameters which will be passed to WKHTMLTOPDF Mail Settings admin email-addresses to send order notification (CSV): Email addresses which will be notified on new orders Send OrderStates as BCC to admin email-addresses: Determines if order-state emails should also be sent to admin-emails Cart Activate automatic cart cleanup: Activate automatic cart cleanup -&gt; cleans inactive and empty carts System - Settings System Settings are defined one time for all shops. System Settings Send Usagelog to CoreShop: Sends an anonymous usagelog to CoreShop Developer Currency Automatic Exchange Rates: Describes if exchange rates should be fetched automatically Exchange Rate Provider: Describes which exchange rate provider should be used.","tags":"","url":"User_Documentation\/Settings.html"},{"title":"Price Rules","text":"CoreShop Price Rules CoreShop Price Rules are very powerful tools for price calculation. This section will help you to get a detailed overview about how price calculation works in CoreShop: Types of Price Rules There are three Price Rule Types. 1. Cart Price Rules Apply Price Rule to the customers cart. 2. Product Price Rules Apply Price Rule globally. 3. Specific Product Prices Apply Price Rules to specific products. Global Priority Product Price Rules first Specific Price Rules second Example 1: Given: Product A with price 100,- Product Price Rule for Product A: New Price 50,- Specific Price Rule for Product A: New Price: 20,- Given Price: 20,- Example 2: Given: Product A with price 100,- Product Price Rule for Product A: Discount Percentage 50% Specific Price Rule for Product A: New Price: 50,- Given Price: 25,- Specific Price Priority Since it's possible to add multiple Specific Price Rules per Product you can adjust the priority via the priority number field. Automatic Rule Availability Checker Rules with time-span elements included on root level will be disabled automatically if they're outdated. Read more about automation here. More Information Cart Price Rules Product Price Rules Specific Product Prices Vouchers Available Actions Available Conditions","tags":"","url":"User_Documentation\/Price_Rules\/index.html"},{"title":"Cart Price Rules","text":"CoreShop Cart Price Rules Documentation Cart price rules in CoreShop provide a flexible way to offer discounts and promotions in your e-commerce store built on the Pimcore platform. These rules can be based on various conditions, such as cart subtotal, specific products, customer groups, or other criteria. This documentation will guide you through creating and managing cart price rules in CoreShop. Available Actions Free Shipping Gift Product Discount Amount Discount Percent Available Conditions Customers Customer Groups Time Span Voucher Amount Countries Zones Stores Currencies Carriers Nested Rules Products Categories","tags":"","url":"User_Documentation\/Price_Rules\/Cart_Price_Rules.html"},{"title":"Product Price Rules","text":"CoreShop Product Price Rules Documentation Product price rules in CoreShop offer a flexible way to provide discounts and special pricing for products in your e-commerce store built on the Pimcore platform. These rules can be based on various conditions and can apply to specific products, categories, or customer groups. This documentation will guide you through creating and managing product price rules in CoreShop. Available Actions Price Discount Price Discount Amount Discount Percent Available Conditions Customers Customer Groups Time Span Voucher Countries Zones Stores Currencies Nested Rules Products Categories","tags":"","url":"User_Documentation\/Price_Rules\/Product_Price_Rules.html"},{"title":"Specific Price Rules","text":"CoreShop Specific Price Rules Documentation Specific price rules in CoreShop provide a flexible way to create targeted discounts and special pricing for products in your e-commerce store built on the Pimcore platform. These rules apply directly to individual products or variants and can be based on customer groups, currencies, or countries. This documentation will guide you through creating and managing specific price rules in CoreShop. Available Actions Price Discount Price Discount Amount Discount Percent Available Conditions Customers Customer Groups Time Span Countries Zones Stores Currencies Nested Rules","tags":"","url":"User_Documentation\/Price_Rules\/Specific_Price_Rules.html"},{"title":"Quantity Price Rules","text":"CoreShop Quantity Price Rules Documentation CoreShop Quantity Price Rules provide a flexible way to offer volume-based discounts for products in your e-commerce store built on the Pimcore platform. These rules apply to specific products and offer tiered pricing depending on the quantity purchased. This documentation will guide you through creating and managing quantity price rules in CoreShop. Available Conditions Customers Customer Groups Time Span Countries Zones Stores Currencies Nested Rules","tags":"","url":"User_Documentation\/Price_Rules\/Quantity_Price_Rules.html"},{"title":"Vouchers","text":"CoreShop Vouchers Info: In CoreShop Vouchers are Price Rules too. To use or generate Vouchers you need to add a Cart Price Rule. How to create Vouchers Simple create a new cart price rule and activate &quot;Is Voucher Rule&quot;. With that, the &quot;Voucher Codes&quot; tab gets enabled. Voucher Condition If you need more control about handling Vouchers you need to add the &quot;Voucher&quot; Condition: Name Description Max. Usage per Code Define how often a voucher code can be used. Allow only one Voucher per Code If checked, only one Voucher per Cart is allowed. Voucher Codes Within the &quot;Voucher Codes&quot; tab you're able to manage codes for the current price rule. It's also possible to export generated codes to csv file. If you need more globally statistics about vouchers please use the voucher report. Name Description Code Generated voucher code Creation Date Voucher creation date Used If the Voucher has been used you'll see a true statement Uses Amount of uses per code Action It's possible to delete voucher codes as long they're not in use Create Voucher Code There are two ways to generate Codes: Single Voucher Code Create a single voucher code. The input field allows any string input, however if you already have added a code with the same string, you'll get a unique error message. Voucher Codes Generator This is the more advanced option to generate voucher codes: Name Description Amount Define how many voucher codes should be generated Length Define the Voucher Code Length Format Voucher Format. Possible Values: Alphanumeric, Alphabetic, Numeric Prefix Define a prefix for each code. For example SHOP- Suffix Define a suffix for each code. For example -SHOP Hyphens all X characters Add a Dash (-) after every X character","tags":"","url":"User_Documentation\/Price_Rules\/Vouchers.html"},{"title":"Actions","text":"CoreShop Price Rule Actions Get a brief overview of all the available Price Rule Actions in CoreShop. Free Shipping Available for: Cart Price Rules Add this action to allow free shipping. Gift Product Available for: Cart Price Rules Add this action to place a gift in customers cart. Options Name Description Gift Product Needs to be a coreshop registered product object Discount Amount Available for: Cart Price Rules, Specific Product Price, Product Price Set a arbitrary amount of discount. Options Name Description Amount Define Amount Gross If given Amount has included VAT, check it Currency Set Currency of given amount Apply On Select Between total and subtotal. Note: This option is only available in the cart rule context Discount Percent Available for: Cart Price Rules, Specific Product Price, Product Price Set a arbitrary percentage amount of discount. Options Name Description Percent Define Amount Apply On Select Between total and subtotal. Note: This option is only available in the cart rule context New Price Available for: Specific Product Price, Product Price Define a new Price. Note: This will be used as a new price in frontend so there is no &quot;special discount price&quot; labelling. If you need a highlighted discount price, use the Discount Price Action. Options Name Description Price Set new Price Currency Set Currency of given amount Discount Price Available for: Specific Product Price, Product Price Define a discount Price. Options Name Description Price Set discount Price Currency Set Currency of given amount","tags":"","url":"User_Documentation\/Price_Rules\/Actions.html"},{"title":"Conditions","text":"CoreShop Price Rules Conditions Get a brief overview of all the available Price Rule Conditions in CoreShop. Customers Available for: Cart Price Rules, Specific Product Prices, Product Price Define one ore more customers to whom the price rule should get applied. Options Name Description Customers One ore multiple CoreShop Customer Objects Customer Groups Available for: Cart Price Rules, Specific Product Prices, Product Price Define one ore more customer groups to whom the price rule should get applied. Options Name Description Groups One ore multiple CoreShop Customer Group Objects Time Span Available for: Cart Price Rules, Specific Product Prices, Product Price Define a time span in which range the price rule is valid Options Name Description Date From Date\/Time Start Date To Date\/Time End Voucher Available for: Cart Price Rules Define some Voucher Conditions. Check out the Voucher Section to learn more about Voucher Configuration. Options Name Description Max. Usage per Code Define how often a voucher code can be used. Allow only one Voucher per Code If checked, only one Voucher per Cart is allowed. Amount Available for: Cart Price Rules Define a Price range within the price rule should get applied. Options Name Description Min Amount The min amount of cart Max Amount The max amount of cart Countries Available for: Cart Price Rules, Specific Product Prices, Product Price Bind a specific country to the price rule. Important: This Condition is connected with the Country Context Resolver. This Condition does not implies to use the Users current location since the Resolver could be also store related. Options Name Description Countries Select one or multiple Countries Zones Available for: Cart Price Rules, Specific Product Prices, Product Price Bind a specific zone to the price rule. Important: This Condition is connected with the Country Context Resolver. This Condition does not implies to use the Users current location since the Resolver could be also store related. Options Name Description Zones Select one or multiple Zones Stores Available for: Cart Price Rules, Specific Product Prices, Product Price Bind a specific store to the price rule. Options Name Description Stores Select one or multiple Stores Currencies Available for: Cart Price Rules, Specific Product Prices, Product Price Define which currencies are valid to apply the price rule Options Name Description Currencies Select one or multiple Currencies Carriers Available for: Cart Price Rules Define which carriers are valid to apply the price rule Options Name Description Carriers Select one or multiple Carriers Nested Rules Available for: Cart Price Rules, Specific Product Prices, Product Price Build complex AND, OR and NOT nested conditions. Within a nested rules it's possible to add any other condition again. Options Name Description Operator AND, OR and NOT Products Available for: Cart Price Rules, Product Price Apply rule only if given products are available. Options Name Description Products One ore multiple CoreShop Product Objects Categories Available for: Cart Price Rules, Product Price Apply rule only if products linked with given categories are available. Options Name Description Categories One ore multiple CoreShop Category Objects","tags":"","url":"User_Documentation\/Price_Rules\/Conditions.html"},{"title":"Localization","text":"CoreShop Localization Countries States Zones Currencies Taxes TaxRules","tags":"","url":"User_Documentation\/Localization\/index.html"},{"title":"Countries","text":"CoreShop Country A Country consists of following values: Name ISO-Code Active: Determines if customers from this country are able to purchase from your store Use Store default Currency: If checked, your stores default currency will be applied to the country Currency Zone Stores: Determines for which Stores this Country is available.","tags":"","url":"User_Documentation\/Localization\/Countries.html"},{"title":"States","text":"CoreShop State A State\/County consists of following values: Name Iso Code Active Country","tags":"","url":"User_Documentation\/Localization\/States.html"},{"title":"Zones","text":"CoreShop Zone A Country consists of following values: Name Active Zones are basically just a group of countries and can be used for Price Rules and Shipping Rules.","tags":"","url":"User_Documentation\/Localization\/Zones.html"},{"title":"Currencies","text":"CoreShop Currencies A Currency consists of following values: Name ISO Code Numeric ISO Code Symbol Exchange Rate: Is used to convert between different currencies If you are going to use Currency conversion, you need to update exchange ranges regularly. Automated Exchange Rates CoreShop supports mulitple providers to get exchange ranges from. Currently supported: CentralBankOfRepulicTurkey EuropeanCentralBank GoogleFinance NationalBankOfRomania YahooFinance WebserviceX To activate this feature, enable it within CoreShop Settings and choose your provider.","tags":"","url":"User_Documentation\/Localization\/Currencies.html"},{"title":"Taxes","text":"CoreShop Taxes A Tax Rate consists of following values: Localized Name: This name can also be seen in the cart or on invoices Rate: Tax Rate, for example 20% Active Taxes are going to be used in Tax Rules.","tags":"","url":"User_Documentation\/Localization\/Taxes.html"},{"title":"TaxRules","text":"CoreShop Tax Rules Tax Rules determine which Tax Rate should be used for the customers country\/state. This Tax Rule is then applied to a product. A Tax Rule consists of following values: Name Active Stores: In which Stores this Tax-Rule can be used. Rules: Which Country and\/or State should use which Tax Rate and what should happen when multiple Tax Rates apply.","tags":"","url":"User_Documentation\/Localization\/TaxRules.html"},{"title":"Shipping","text":"CoreShop Shipping CoreShop provides a comprehensive shipping management system that allows you to define and configure various aspects of shipping, such as carriers, shipping rules, and carrier services. Carriers Shipping Rules","tags":"","url":"User_Documentation\/Shipping\/index.html"},{"title":"Carriers","text":"CoreShop Carriers Documentation CoreShop Carriers are an essential part of the shipping process in the CoreShop e-commerce framework, built on the Pimcore platform. Carriers represent shipping providers (e.g., UPS, FedEx, or DHL) and are responsible for delivering orders to customers. This documentation will guide you through the process of creating and managing carriers in CoreShop. Creating a Carrier To create a carrier, follow these steps: Log in to the CoreShop admin interface. Navigate to the &quot;Shipping&quot; tab and click on &quot;Carriers.&quot; Click the &quot;Add new&quot; button to create a new carrier. Enter a name for the carrier and configure the other available options as needed. Carrier Options When creating a carrier, you can configure various options to customize its behavior: Name: A descriptive name for the carrier (e.g., UPS, FedEx, or DHL). Tracking Url: A string value that indicates the tracking url Tax Rule Group: The tax rule group applied to shipping costs for this carrier. If you want to apply taxes to shipping costs, you'll need to create a tax rule group and assign it to the carrier. Shipping Rules: The shipping rules associated with this carrier. Shipping rules define shipping costs based on various conditions such as weight, price, dimensions, and destination. You can assign multiple shipping rules to a carrier, and the system will evaluate them in order of priority to determine the final shipping cost. Summary CoreShop Carriers provide a robust way to manage shipping providers and their associated services. By creating carriers and configuring their options, you can offer customers a range of shipping choices based on factors such as delivery time and cost. Combined with shipping rules, carriers give you the flexibility to create a tailored shipping experience for your e-commerce store.","tags":"","url":"User_Documentation\/Shipping\/Carriers.html"},{"title":"Shipping Rules","text":"CoreShop Shipping Rules Documentation CoreShop Shipping Rules is a powerful feature within the CoreShop e-commerce framework built on the Pimcore platform. It allows you to create flexible and customizable shipping rules that define shipping costs based on various conditions such as weight, price, dimensions, and shipping destination. Overview Shipping rules in CoreShop can be composed of conditions and actions. Conditions determine whether a rule should be applied, while actions define the changes to the shipping costs. CoreShop provides a user-friendly interface for creating and managing shipping rules. You can create multiple rules, each with different conditions and actions, to cover various scenarios. Creating Shipping Rules Navigate to the &quot;Shipping&quot; tab and click on &quot;Shipping Rules.&quot; Click the &quot;Add new&quot; button to create a new shipping rule. Enter a name for the rule and configure the other available options as needed. Configuring Conditions Conditions determine whether the shipping rule should be applied to an order. You can create multiple conditions for a single rule, and all conditions must be met for the rule to be applied. CoreShop offers several types of conditions, including: Weight: Based on the total weight of the order. Price: Based on the total price of the order. Dimension: Based on the dimensions (length, width, and height) of the order. Quantity: Based on the total quantity of items in the order. Countries: Based on the shipping destination country. Zones: Based on the shipping destination zone (a group of countries). To add a condition to your shipping rule: Click the &quot;Add Condition&quot; button in the &quot;Conditions&quot; section of the shipping rule. Choose the desired condition type from the dropdown menu. Configure the condition parameters as needed. For example, if you want to apply a shipping rule only to orders with a total weight of over 10kg, you would add a weight condition and set the minimum weight to 10kg. Configuring Actions Actions define the changes to the shipping costs when a rule is applied. You can create multiple actions for a single rule. CoreShop offers several types of actions, including: Discount Amount: Apply a fixed discount amount to the shipping cost. Discount Percentage: Apply a percentage discount to the shipping cost. Add Amount: Add a fixed amount to the shipping cost. Add Percentage: Add a percentage amount to the shipping cost. To add an action to your shipping rule: Click the &quot;Add Action&quot; button in the &quot;Actions&quot; section of the shipping rule. Choose the desired action type from the dropdown menu. Configure the action parameters as needed. For example, if you want to apply a 20% discount to the shipping cost when the rule is applied, you would add a discount percentage action and set the percentage value to 20. Summary CoreShop Shipping Rules offer a powerful and flexible way to define and manage shipping costs for your e-commerce store. By creating various conditions and actions, you can customize shipping costs based on factors such as weight, price, dimensions, and destination. This allows you to cater to different customer needs and provide more accurate shipping estimates.","tags":"","url":"User_Documentation\/Shipping\/Shipping_Rules.html"},{"title":"Cart","text":"CoreShop Cart Inventory Change If a customer adds a item to the cart CoreShop will check if product stock is sufficient. If not, a form error will show up. Disable \/ Delete Products If a product gets disabled or deleted in backend CoreShop will automatically remove this product from all active carts. A form error will notify every customer in frontend if the cart has been modified. Abandoned Carts No cart gets deleted by default. This allows you to: check abandoned cart statistics build your own business logic in case you want to inform customers within a follow-up email for example There is a expire cart command to remove abandoned carts, please checkout the development section.","tags":"","url":"User_Documentation\/Cart\/index.html"},{"title":"Order","text":"CoreShop Order Orders Order Detail Order Workflow Order Comments","tags":"","url":"User_Documentation\/Order\/index.html"},{"title":"Orders","text":"CoreShop Orders Grid View The default order list is based on the pimcore grid view. CoreShop comes with a default column configuration: On the right side, click &quot;Column configuration&quot; and select &quot;Order Overview&quot;. Now click that button again and select &quot;Set as favorite&quot;. Filters in Grid View It's possible to add custom filter definitions based on your project. This has to be done via a php service. Read more about it here. Apply Actions in Grid View It's possible to apply custom bulk actions for selected orders. This has to be done via a php service. Read more about it here.","tags":"","url":"User_Documentation\/Order\/Orders.html"},{"title":"Order Detail","text":"Order Detail State \/ Price Overview Please read more about the order workflow process here Besides some useful information about the order store and the total order amount, there're also several order states: State This is the main state and represents the summary of all order states. Name Description new New order has been placed. confirmed New order has been successfully created (after a offline order or a customer returns from payment gateway regardless of its state). cancelled Order has been cancelled. complete Order is complete. Payment State Global payment states per order and represents the summary of all order payments: Name Description new New payment has been created. awaiting_payment Waiting for payment: User is on payment offsite or payment is offline. partially_paid Some order payments have been paid. paid All payments have been paid. cancelled Order is complete. partially_refunded Some order payments have been refunded. refunded All payments have been refunded. Shipment State Global shipment states per order and represents the summary of all order shipments: Name Description new New shipment has been placed. cancelled Shipment has been cancelled partially_shipped Some order items have been shipped. shipped All items have been shipped. Invoice State Global invoice states per order and represents the summary of all order invoices: Name Description new New invoice has been created. cancelled Invoice has been cancelled partially_invoiced Some invoices have been invoiced. invoiced All invoices have been invoiced. Carrier\/Payment Provider Info Currency of Order Overall weight of Order Items Carrier Total Amount Order History The Order History shows you when specific states have been changed. Payments -- Shipments -- Invoices -- Mail Correspondence -- Customer -- Comments -- Additional Data -- Products --","tags":"","url":"User_Documentation\/Order\/Order_Detail.html"},{"title":"Order Workflow","text":"Order Workflow Technical Overview of CoreShop Workflows. Change States States can be changed for: Order, Payment, Shipment and Invoice. If any transition is available, you'll find a colored state button. Click on that button to change the state. Order Completion In CoreShop a order is complete after the order payment reaches the paid state and order shipment reaches the shipped state. If you also want to include the order invoice state invoiced before a order gets completed, you need to enable a configuration flag: ## app\/config\/config.yml parameters: coreshop.workflow.include_invoice_state_to_complete_order: true Order Cancellation In CoreShop a order rarely gets cancelled. Some reasons are: Front-End Revise After a customer has cancelled his payment he will reach a so called revise page. From there he's able to reselect a payment gateway to start over. In revise mode, however, it's possible to cancel the order and restore the cart. Only than the order gets cancelled. Back-End Revise In CoreShop it's possible to create orders in Back-End. Instead of adding sensitive payment information, you're able to provide a revise link to your customer which then works the same as the Front-End revise process (except that your customer is not able to restore a cart since there never was one). Please read more about the canceling process here Payment Workflow Create a Payment Just use the green bottom on the right top corner to add a new shipment. A payment creation normally gets created by a frontend payment gateway. This gateway also handles all the payment state changes. Workflow Rules A payment reaches the new state after its creation. A payment can be canceled as long it's in the new or processing state. After a payment reaches completed state it only can get refunded. Attention: The Refund process is not implemented yet in Coreshop! Shipment Workflow Create a Shipment Just use the green bottom on the right top corner to add a new shipment. If there are enough shippable items you can create a shipment. Workflow Rules A shipment reaches the ready state (triggered by a create transition) after its creation. A shipment can be canceled as long it's in the ready state After you provoked the ship state a shipment can't be cancelled anymore. Invoice Workflow Create Invoice Just use the green bottom on the right top corner to add a new invoice. If there are enough invoiceable items you can create a invoice. Workflow Rules A invoice reaches the ready state (triggered by a create transition) after its creation. A invoice can be canceled as long it's in the ready state. Please note: Cancelling an invoice is not a refund action. You're allowed to create another invoice after cancelling the previous one. After you provoked the complete state a invoice can't be cancelled anymore which means the invoice has been finally captured. After that you need to go on with a refund process Attention: The Refund process is not implemented yet in Coreshop!","tags":"","url":"User_Documentation\/Order\/Order_Workflow.html"},{"title":"Order Comments","text":"Order Comments CoreShop provides a simple comment interface which allows you to add simple notes to every order. It's also possible to send the order comment to the customer. Just check &quot;Submit Comment to Customer&quot;. Note: You need a valid Notification Rule to send comments to user.","tags":"","url":"User_Documentation\/Order\/Order_Comments.html"},{"title":"Catalog","text":"CoreShop Catalog Products Product Variants Categories","tags":"","url":"User_Documentation\/Catalog\/index.html"},{"title":"Products","text":"CoreShop Products Documentation Products are the core of any e-commerce store built on the Pimcore platform. CoreShop provides a flexible and feature-rich system for managing products, including product variants, attributes, images, and more.","tags":"","url":"User_Documentation\/Catalog\/Products.html"},{"title":"Product Variants","text":"Product Variants CoreShop has the Variant Bundle to handle Variants, see here.","tags":"","url":"User_Documentation\/Catalog\/Product_Variants.html"},{"title":"Categories","text":"CoreShop Categories Documentation Categories in CoreShop provide a way to organize and structure the products in your e-commerce store built on the Pimcore platform. Using categories, you can create a hierarchical navigation system that allows customers to browse and find products easily.","tags":"","url":"User_Documentation\/Catalog\/Categories.html"},{"title":"Geo IP","text":"CoreShop can use GeoIP to locate visitors countries using IP-Addresses. CoreShop uses the already existing Pimcore GeoIP Database located in: \/var\/config\/GeoLite2-City.mmdb","tags":"","url":"User_Documentation\/Geo_IP.html"},{"title":"Inventory","text":"CoreShop Inventory The Inventory is a complex topic since there is a lot of business logic you need to know about. Product Inventory Every Product object comes with a &quot;Stock&quot; Tab. Let's have a look about the configuration: Name Description Is Tracked Define if a product should get tracked On Hand Amount of available products. On Hold Defines how many elements are currently locked. Do not change that value unless you know what you're doing. Is Tracked If you want to enable the inventory feature for a product, you need to check this setting. After that this product is not orderable in frontend if stock is insufficient. Note: Only if you enable &quot;Is Tracked&quot; the inventory stock is active! Otherwise the product is always available regardless of it's stock amount. On Hand Define a available amount for each product. With every successfully order, an arbitrary amount will be subtracted. On Hold This one needs some further explanation: After the checkout is complete, all ordered items will be removed from &quot;On Hand&quot; and get moved to &quot;On Hold&quot; until the payment is complete: If the unpaid order gets cancelled, the reserved &quot;On Hold&quot; amount gets back to &quot;On Hand&quot;. If the order payment status switches to paid, the reserved &quot;On Hold&quot; amount gets subtracted. Cart \/ Checkout If a product stock gets insufficient during a customers checkout, the product gets removed from customers cart following by a form error.","tags":"","url":"User_Documentation\/Inventory\/index.html"},{"title":"Reports","text":"CoreShop Reports Sales Cart\/Order Conversion Abandoned Carts Products Categories Customers Carrier Distribution Payment Distribution Vouchers","tags":"","url":"User_Documentation\/Reports\/index.html"},{"title":"Sales","text":"CoreShop Sales Report Type Has Pagination Cartesian Chart No Available Filters Name Description Store Filter by Store Day Shortcut Filter by current Day Month Shortcut Filter by current Month Year Shortcut Filter by current Year Day -1 Shortcut Filter by last Day Month -1 Shortcut Filter by last Month Year -1 Shortcut Filter by last Year From Date to Start Filter To Date to End Filter Group By Group Filter by Day, Month, Year Available Chart Fields Name Description Y Amount (Sales) X Date","tags":"","url":"User_Documentation\/Reports\/Sales.html"},{"title":"Carts","text":"CoreShop Cart\/Order Conversion Report Type Has Pagination Cartesian Chart No Available Filters Name Description Store Filter by Store Day Shortcut Filter by current Day Month Shortcut Filter by current Month Year Shortcut Filter by current Year Day -1 Shortcut Filter by last Day Month -1 Shortcut Filter by last Month Year -1 Shortcut Filter by last Year From Date to Start Filter To Date to End Filter Available Chart Fields Name Description Y Amount (Cart, Order) X Date","tags":"","url":"User_Documentation\/Reports\/Carts.html"},{"title":"Abandoned Carts","text":"CoreShop Abandoned Carts Report Type Has Pagination List Yes Available Filters Name Description Store Filter by Store Day Shortcut Filter by current Day Month Shortcut Filter by current Month Year Shortcut Filter by current Year Day -1 Shortcut Filter by last Day Month -1 Shortcut Filter by last Month Year -1 Shortcut Filter by last Year From Date to Start Filter To Date to End Filter Available Grid Fields Name Description Customer Name Customer name (if available) Email Customer Email (if available) Selected Payment Name of selected Payment Creation Date Creation Date Modification Date Modification Date Items in Cart Amount of Items in Cart Action Open Cart Object","tags":"","url":"User_Documentation\/Reports\/Abandoned_Carts.html"},{"title":"Products","text":"CoreShop Products Report Type Has Pagination List Yes Available Filters Name Description Store Filter by Store Day Shortcut Filter by current Day Month Shortcut Filter by current Month Year Shortcut Filter by current Year Day -1 Shortcut Filter by last Day Month -1 Shortcut Filter by last Month Year -1 Shortcut Filter by last Year From Date to Start Filter To Date to End Filter Product Types Group Filter by Main Products, Variants, Container Products Product Types Name Description Main Products Only show Products without Variant inclusion Variants Only show Variant Product Types Container Products Show Sum of Products and Child-Products. Note: Container Products are bounded to the original pimcore objects. The products will be ignored in this report, if those main-objects have been deleted! Available Grid Fields Name Description Name Product Name Order Count Amount of Order Quantity Quantity Sale Price Sale Price Sales Amount of Sales Profit Amount of Profit","tags":"","url":"User_Documentation\/Reports\/Products.html"},{"title":"Categories","text":"CoreShop Categories Report Type Has Pagination List No Available Filters Name Description Store Filter by Store Day Shortcut Filter by current Day Month Shortcut Filter by current Month Year Shortcut Filter by current Year Day -1 Shortcut Filter by last Day Month -1 Shortcut Filter by last Month Year -1 Shortcut Filter by last Year From Date to Start Filter To Date to End Filter Available Grid Fields Name Description Name Product Name Order Count Amount of Orders Quantity Quantity Sales Sales Profit Profit","tags":"","url":"User_Documentation\/Reports\/Categories.html"},{"title":"Customers","text":"CoreShop Customers Report Type Has Pagination List No Available Filters Name Description Store Filter by Store Day Shortcut Filter by current Day Month Shortcut Filter by current Month Year Shortcut Filter by current Year Day -1 Shortcut Filter by last Day Month -1 Shortcut Filter by last Month Year -1 Shortcut Filter by last Year From Date to Start Filter To Date to End Filter Available Grid Fields Name Description Name Customer Name Order Count Amount of Orders Sales Sales","tags":"","url":"User_Documentation\/Reports\/Customers.html"},{"title":"Carrier Distribution","text":"CoreShop Carrier Distribution Report Type Has Pagination Pie Chart No Available Filters Name Description Store Filter by Store Day Shortcut Filter by current Day Month Shortcut Filter by current Month Year Shortcut Filter by current Year Day -1 Shortcut Filter by last Day Month -1 Shortcut Filter by last Month Year -1 Shortcut Filter by last Year From Date to Start Filter To Date to End Filter Available Chart Fields Carrier Distribution","tags":"","url":"User_Documentation\/Reports\/Carrier_Distribution.html"},{"title":"Payment Distribution","text":"CoreShop Payment Distribution Report Type Has Pagination Pie Chart No Available Filters Name Description Store Filter by Store Day Shortcut Filter by current Day Month Shortcut Filter by current Month Year Shortcut Filter by current Year Day -1 Shortcut Filter by last Day Month -1 Shortcut Filter by last Month Year -1 Shortcut Filter by last Year From Date to Start Filter To Date to End Filter Available Chart Fields Payment Provider Distribution","tags":"","url":"User_Documentation\/Reports\/Payment_Distribution.html"},{"title":"Vouchers","text":"CoreShop Voucher Report Type Has Pagination List Yes Available Filters Name Description Store Filter by Store Day Shortcut Filter by current Day Month Shortcut Filter by current Month Year Shortcut Filter by current Year Day -1 Shortcut Filter by last Day Month -1 Shortcut Filter by last Month Year -1 Shortcut Filter by last Year From Date to Start Filter To Date to End Filter Available Grid Fields Name Description Code Applied Code Discount Amount of Discount Price Rule Name of applied Price Rule Applied Date Applied Date","tags":"","url":"User_Documentation\/Reports\/Vouchers.html"},{"title":"Automation","text":"CoreShop Automation In CoreShop there are several automation mechanism implemented. Order Cancellation Execution Time: Once per day via maintenance job CoreShop will automatically cancel orders older than 20 days. Change Orders Expiration Date core_shop_order: expiration: order: days: 30 Expired Carts Execution Time: Once per day via maintenance job Note: By default, this feature is disabled. By default, this feature is disabled (days = 0) so no carts will be removed by default. If you want to remove older carts, just enable it via configuration: Change Cart Expiration Date core_shop_order: expiration: cart: days: 20 anonymous: true customer: true Expired Rules Execution Time: Once per day via maintenance job If you're having a lot of active rules in your system, you may want to disable them via automation. CoreShop already comes with a time-span check, which means all rules with time-span elements will be disabled if they're outdated. If you want do implement some further availability logic, you could use the coreshop.rule.availability_check Event to define the availability of the rule. Just use the setAvailability() method to override the system availability suggestion.","tags":"","url":"User_Documentation\/Automation\/index.html"},{"title":"Development","text":"CoreShop The Developer\u2019s guide to leveraging the flexibility of CoreShop. Here you will find all the concepts used in CoreShop. Introduction CoreShop Resources CoreShop uses Doctrine ORM for Custom Resources. ORM enables us great flexibility and extendability for simple models like Currencies and Countries. CoreShop currently implements these Resources as ORM Model: Currency Country and State Tax Rate and Tax Rules Price Rules Carrier Shipping Rules Index and Filter Configuration Notification Rule Configuration Stores Payments Everytime something is called a Resource, we talk about ORM Models. CoreShop Pimcore Models CoreShop also takes advantage of Pimcores flexible data-model. Objects that are heavily used and changed are implemented using Data Objects: Product Product Category Manufacturer Cart Order Order Invoice Order Shipment Quote Customer Customer Group Addresses Everytime we talk about Objects, we talk about Pimcore Data Objects.","tags":"","url":"Development\/index.html"},{"title":"Extend CoreShop Resources","text":"Extend CoreShop Resources All models in Coreshop are placed in the Coreshop\\Component\\*ComponentName*\\Model namespaces alongside with their interfaces. Many models in CoreShop are extended in the Core component. If the model you are willing to override exists in the Core you should be extending the Core one, not the base model from the component. How to Customize a Model First things first: If you want to extend coreshop models your Bundle must extend the AbstractResourceBundle. Next you have set your supported drivers. Just add the following lines of code to your bundle class: public function getSupportedDrivers(); array { return [ CoreShopResourceBundle::DRIVER_DOCTRINE_ORM ]; } After that have to tell the bundle where your models are. For that, add the override the following method in your bundle class and return the model namespace. Here is an example for the AppBundle protected function getModelNamespace(): string { return &quot;AppBundle\\Model&quot;; } Here a quick overview for you which dictories are important for you, when customizing CoreShop models. Folder Description AcmeBundle\/Model or AcmeBundle\/Entity Where your models are living AcmeBundle\/config\/doctrine\/model Put your doctrine .yml config files in here AcmeBundle\/config\/serializer The serializer configs for the models Let\u2019s take the CoreShop\\Component\\Currency\\Model\\Currency as an example. This one is extended in Core. How can you check that? First of all, you need to find the current used class by doing following: $ php bin\/console debug:container --parameter=coreshop.model.currency.class As a result you will get the CoreShop\\Component\\Core\\Model\\Currency - this is the class that you need to be extending. Assuming you want to add a field called flag 1. The first thing to do is to write your own class which will extend the base Currency class &lt;?php namespace AppBundle\\Entity; use CoreShop\\Component\\Core\\Model\\Currency as BaseCurrency; class Currency extends BaseCurrency { \/** * @var bool *\/ private $flag; \/** * @return bool *\/ public function getFlag() { return $this-&gt;flag; } \/** * @param bool $flag *\/ public function setFlag($flag) { $this-&gt;flag = $flag; } } 2. Next define your entity\u2019s mapping. The file should be placed in AppBundle\/Resources\/config\/doctrine\/Currency.orm.yml AppBundle\\Entity\\Currency: type: mappedSuperclass table: coreshop_currency fields: flag: type: boolean nullable: true 3. Finally you\u2019ll need to override the model\u2019s class in the app\/config\/config.yml. Under the core_shop_* where * is the name of the bundle of the model you are customizing, in our case it will be the CoreShopCurrencyBundle -&gt; core_shop_currency. core_shop_currency: resources: currency: classes: model: AppBundle\\Entity\\Currency 4. Update the database. There are two ways to do it. via direct database schema update: $ php bin\/console doctrine:schema:update --force via migrations: Which we strongly recommend over updating the schema. $ php bin\/console doctrine:migrations:diff $ php bin\/console doctrine:migrations:migrate","tags":"","url":"Development\/Extending_Guide\/Extend_CoreShop_Resources.html"},{"title":"Extend CoreShop Forms","text":"Customizing Forms The forms in CoreShop are placed in the CoreShop\\Bundle\\*BundleName*\\Form\\Type namespaces and the extensions will be placed in AppBundle\\Form\\Extension. Why would you customize a Form? There are plenty of reasons to modify forms that have already been defined in CoreShop. Your business needs may sometimes slightly differ from our internal assumptions. You can: add completely new fields, modify existing fields, make them required, change their HTML class, change labels etc., remove fields that are not used. How to customize a CoreShop Resource Form? If you want to modify the form for the Store in your system there are a few steps that you should take. Assuming that you would like to (for example): Add a contactHours field, These will be the steps that you will have to take to achieve that: 1. If your are planning to add new fields remember that beforehand they need to be added on the model that the form type is based on. In case of our example if you need to have the contactHours on the model and the entity mapping for the Store resource. To get to know how to prepare that go there 2. Create a Form Extension. Your form has to extend a proper base class. How can you check that? For the StoreType run: $ php bin\/console debug:container coreshop.form.type.store As a result you will get the CoreShop\\Bundle\\StoreBundle\\Form\\Type\\StoreType - this is the class that you need to be extending. &lt;?php namespace AppBundle\\Form\\Extension; use CoreShop\\Bundle\\StoreBundle\\Form\\Type\\StoreType; use Symfony\\Component\\Form\\AbstractTypeExtension; use Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType; use Symfony\\Component\\Form\\FormBuilderInterface; final class StoreTypeExtension extends AbstractTypeExtension { public function buildForm(FormBuilderInterface $builder, array $options): void { \/\/ Adding new fields works just like in the parent form type. $builder-&gt;add('contactHours', TextType::class, [ 'required' =&gt; false ]); } public static function getExtendedTypes(): array { return [StoreType::class]; } } 3. After creating your class, register this extension as a service in the AppBundle\/Resources\/config\/services.yml: services: app.form.extension.type.customer_profile: class: AppBundle\\Form\\Extension\\StoreTypeExtension tags: - { name: form.type_extension, extended_type: CoreShop\\Bundle\\StoreBundle\\Form\\Type\\StoreType } In our case you will need to extend the ExtJs Form as well: src\/AppBundle\/Resources\/public\/pimcore\/js\/store.js. In ExtJs your new store file need to like like this: coreshop.store.item = Class.create(coreshop.store.item, { getFormPanel: function ($super) { var panel = $super(); panel.down(&quot;fieldset&quot;).add( [ { xtype: 'textfield', fieldLabel: 'Contact Hours', name: 'contactHours' } ] ); return this.formPanel; } }); And you need to configure it to be loaded as well: core_shop_store: pimcore_admin: js: custom_store: '\/bundles\/app\/pimcore\/js\/store.js'","tags":"","url":"Development\/Extending_Guide\/Extend_CoreShop_Forms.html"},{"title":"Extend CoreShop DataObjects","text":"Extending CoreShop CoreShop Data Objects (like CoreShopProduct or CoreShopOrder) can be changed directly within Pimcore. Replace CoreShop Object Classes with your own Classes CoreShop uses Pimcore Parameters to determine the Pimcore Object Class. To change it, simply add this to your config.yml core_shop_order: pimcore: order: classes: model: 'Pimcore\\Model\\DataObject\\MyOrderClass' install_file: '@AppBundle\/Resources\/install\/pimcore\/classes\/MyOrderClass.json' repository: AppBundle\\Repository\\OrderRepository factory: AppBundle\\Factory\\OrderFactory","tags":"","url":"Development\/Extending_Guide\/Extend_CoreShop_DataObjects.html"},{"title":"Extending Rule Actions","text":"Custom Price-Rule\/Shipping-Rule\/Notification-Rule Actions Adding Price-, Shipping- or Notification-Rule Actions is the same for all of these types. Their only difference is the tag you use and Interface you need to implement for them. Action Type Tag Interface Cart Price Rule coreshop.cart_price_rule.action CoreShop\\Component\\Order\\Cart\\Rule\\Action\\CartPriceRuleActionProcessorInterface Product Price Rule coreshop.product_price_rule.action CoreShop\\Component\\Product\\Rule\\Action\\ProductPriceActionProcessorInterface Product Specific Price coreshop.product_specific_price_rule.action CoreShop\\Component\\Product\\Rule\\Action\\ProductPriceActionProcessorInterface Shipping Rule coreshop.shipping_rule.action CoreShop\\Component\\Shipping\\Rule\\Action\\CarrierPriceActionProcessorInterface Notification Rule coreshop.notification_rule.action CoreShop\\Component\\Notification\\Rule\\Action\\NotificationRuleProcessorInterface Example Adding a new Action Now, lets add a new Action for Product Price Rules. To do so, we first need to create a new class and implement the interface listed in the table above. For Product Price Rules, we need to use CoreShop\\Component\\Product\\Rule\\Action\\ProductPriceActionProcessorInterface \/\/AppBundle\/CoreShop\/CustomAction.php namespace AppBundle\\CoreShop; final class CustomAction implements \\CoreShop\\Component\\Product\\Rule\\Action\\ProductPriceActionProcessorInterface { public function getPrice($subject, array $context, array $configuration): int { \/\/If your action gives the product a new Price, put your calculation here return $configuration['some_value']; } } We also need a FormType for the actions configurations: \/\/AppBundle\/Form\/Type\/CustomActionType.php namespace AppBundle\\Form\\Type; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\FormBuilderInterface; use Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType; final class CustomActionType extends AbstractType { \/** * {@inheritdoc} *\/ public function buildForm(FormBuilderInterface $builder, array $options): void { $builder -&gt;add('some_value', TextType::class) ; } } With configuration, comes a Javascript file as well: \/\/AppBundle\/Resources\/public\/pimcore\/js\/custom_action.js pimcore.registerNS('coreshop.product.pricerule.actions.custom'); coreshop.product.pricerule.actions.custom = Class.create(coreshop.rules.actions.abstract, { type: 'custom', getForm: function () { var some_value = 0; var me = this; if (this.data) { some_value = this.data.some_value \/ 100; } var some_valueField = new Ext.form.NumberField({ fieldLabel: t('custom'), name: 'some_value', value: some_value, decimalPrecision: 2 }); this.form = new Ext.form.Panel({ items: [ some_valueField ] }); return this.form; } }); Don't forget to run the following command afterwards to deploy it if needed. If you're using the latest symfony structure, omit the web. bin\/console assets:install web Registering the Custom Action to the Container and load the Javascript File We now need to create our Service Definition for our Custom Action: app.product_price_rule.custom: class: AppBundle\\CoreShop\\CustomAction tags: - { name: coreshop.product_price_rule.action, type: custom, form-type: AppBundle\\Form\\Type\\CustomActionType } and add this to your config.yml: core_shop_product: pimcore_admin: js: custom_action: '\/bundles\/app\/pimcore\/js\/custom_action.js'","tags":"","url":"Development\/Extending_Guide\/Extending_Rule_Actions.html"},{"title":"Extending Rule Conditions","text":"Custom Price-Rule\/Shipping-Rule\/Notification-Rule Conditions Adding Price-, Shipping- or Notification-Rule Conditions is the same for all of these types. They're only difference is the tag you use and Interface you need to implement for them. Action Type Tag Interface\/AbstractClass Cart Price Rule coreshop.cart_price_rule.condition CoreShop\\Component\\Order\\Cart\\Rule\\Condition\\AbstractConditionChecker Product Price Rule coreshop.product_price_rule.condition CoreShop\\Component\\Rule\\Condition\\ConditionCheckerInterface Product Specific Price coreshop.product_specific_price_rule.condition CoreShop\\Component\\Rule\\Condition\\ConditionCheckerInterface Shipping Rule coreshop.shipping_rule.condition CoreShop\\Component\\Shipping\\Rule\\Condition\\CategoriesConditionChecker Notification Rule coreshop.notification_rule.condition CoreShop\\Component\\Notification\\Rule\\Condition\\AbstractConditionChecker Example Adding a new Condition Now, lets add a new Condition for Product Price Rules. To do so, we first need to create a new class and implement the interface listed in the table above. For Product Price Rules, we need to use CoreShop\\Component\\Rule\\Condition\\ConditionCheckerInterface \/\/AppBundle\/CoreShop\/CustomCondition.php namespace AppBundle\\CoreShop; use CoreShop\\Component\\Resource\\Model\\ResourceInterface; use CoreShop\\Component\\Rule\\Model\\RuleInterface; final class CustomCondition implements \\CoreShop\\Component\\Rule\\Condition\\ConditionCheckerInterface { public function isValid(ResourceInterface $subject, RuleInterface $rule, array $configuration, array $params = []): bool { \/\/return true if valid, false if not return true; } } We also need a FormType for the conditions configurations: \/\/AppBundle\/Form\/Type\/CustomConditionType.php namespace AppBundle\\Form\\Type; final class CustomConditionType extends AbstractType { \/** * {@inheritdoc} *\/ public function buildForm(FormBuilderInterface $builder, array $options): void { $builder -&gt;add('some_value', TextType::class) ; } } With configuration, comes a Javascript file as well: \/\/AppBundle\/Resources\/public\/pimcore\/js\/custom_condition.js pimcore.registerNS('coreshop.product.pricerule.conditions.custom'); coreshop.product.pricerule.conditions.custom = Class.create(coreshop.rules.conditions.abstract, { type: 'custom', getForm: function () { var some_value = 0; var me = this; if (this.data) { some_value = this.data.some_value \/ 100; } var some_valueField = new Ext.form.NumberField({ fieldLabel: t('custom'), name: 'some_value', value: some_value, decimalPrecision: 2 }); this.form = new Ext.form.Panel({ items: [ some_valueField ] }); return this.form; } }); Don't forget to run the following command afterwards to deploy it if needed. If you're using the latest symfony structure, omit the web. bin\/console assets:install web Registering the Custom Condition to the Container and load the Javascript File We now need to create our Service Definition for our Custom Condition: app.product_price_rule.custom_condition: class: AppBundle\\CoreShop\\CustomCondition tags: - { name: coreshop.product_price_rule.condition, type: custom, form-type: AppBundle\\Form\\Type\\CustomConditionType } and add this to your config.yml: core_shop_product: pimcore_admin: js: custom_condition: '\/bundles\/app\/pimcore\/js\/custom_condition.js'","tags":"","url":"Development\/Extending_Guide\/Extending_Rule_Conditions.html"},{"title":"Localization","text":"CoreShop Localization CoreShop provides you with a set of tools for better localization of your eCommerce. These tools exist of following parts: Currencies Countries States Zones Taxes","tags":"","url":"Development\/Localization\/index.html"},{"title":"Currencies","text":"CoreShop Currencies CoreShop is a multi-currency able eCommerce Framework. Therefore it is possible to create and use different currencies. Create, Update, Read, Delete Currency Context","tags":"","url":"Development\/Localization\/Currencies\/index.html"},{"title":"CRUD","text":"CoreShop Currencies Create If you want to create a Currency via API, you can do following: $newCurrency = $container-&gt;get('coreshop.factory.currency')-&gt;createNew(); Now you have a new Currency, if you want to persist it, you need to do following: $container-&gt;get('coreshop.manager.currency')-&gt;persist($newCurrency); $container-&gt;get('coreshop.manager.currency')-&gt;flush(); You now have a new persisted Currency. Read If you want to query for Currencies, you can do following: $currencyRepository = $container-&gt;get('coreshop.repository.currency'); $queryBuilder = $currencyRepository-&gt;createQueryBuilder('c'); \/\/ You can now create your query \/\/ And get the result $currencies = $queryBuilder-&gt;getQuery()-&gt;getResult(); Update If you want to update and existing Currency, you need to do following: \/\/ Fetch Currency $currency = $currencyRepository-&gt;findById(1); $currency-&gt;setName('Euro'); \/\/ And Persist it $container-&gt;get('coreshop.manager.currency')-&gt;persist($currency); $container-&gt;get('coreshop.manager.currency')-&gt;flush(); Delete If you want to update and existing Currency, you need to do following: \/\/ Fetch Currency $currency = $currencyRepository-&gt;findById(1); \/\/ And Persist it $container-&gt;get('coreshop.manager.currency')-&gt;remove($currency); $container-&gt;get('coreshop.manager.currency')-&gt;flush();","tags":"","url":"Development\/Localization\/Currencies\/CRUD.html"},{"title":"Context","text":"CoreShop Currency Context For CoreShop to determine the current currency it uses a concept called context and context resolver. Context Name Priority Tag Description FixedCurrencyContext default coreshop.context.currency Used for testing purposes StorageBasedCurrencyContext default coreshop.context.currency check if a currency has been changed during a frontend request CountryAwareCurrencyContext default coreshop.context.currency Mostly this context will apply since it will get the currency based on the current country context These Contexts take care about finding the correct currency for the current request. Create a Custom Resolver A Currency Context needs to implement the interface CoreShop\\Component\\Currency\\Context\\CurrencyContextInterface. This interface consists of one method called getCurrency which returns a CoreShop\\Component\\Currency\\Model\\CurrencyInterface or throws an CoreShop\\Component\\Currency\\Context\\CurrencyNotFoundException To register your context, you need to use the tag: coreshop.context.currency with an optional priority attribute.","tags":"","url":"Development\/Localization\/Currencies\/Context.html"},{"title":"Countries","text":"CoreShop Countries CoreShop is a multi-country able eCommerce Framework. Therefore it is possible to create and use different Countries. Create, Update, Read, Delete Country Context","tags":"","url":"Development\/Localization\/Countries\/index.html"},{"title":"CRUD","text":"CoreShop Countries Create If you want to create a Country via API, you can do following: $newCountry = $container-&gt;get('coreshop.factory.country')-&gt;createNew(); Now you have a new Country, if you want to persist it, you need to do following: $container-&gt;get('coreshop.manager.country')-&gt;persist($newCountry); $container-&gt;get('coreshop.manager.country')-&gt;flush(); You now have a new persisted Country. Read If you want to query for Countries, you can do following: $countryRepository = $container-&gt;get('coreshop.repository.country'); $queryBuilder = $countryRepository-&gt;createQueryBuilder('c'); \/\/ You can now create your query \/\/ And get the result $countries = $queryBuilder-&gt;getQuery()-&gt;getResult(); Update If you want to update and existing Country, you need to do following: \/\/ Fetch Country $country = $countryRepository-&gt;findById(1); $country-&gt;setName('Euro'); \/\/ And Persist it $container-&gt;get('coreshop.manager.country')-&gt;persist($country); $container-&gt;get('coreshop.manager.country')-&gt;flush(); Delete If you want to update and existing Country, you need to do following: \/\/ Fetch Country $country = $countryRepository-&gt;findById(1); \/\/ And Persist it $container-&gt;get('coreshop.manager.country')-&gt;remove($country); $container-&gt;get('coreshop.manager.country')-&gt;flush();","tags":"","url":"Development\/Localization\/Countries\/CRUD.html"},{"title":"Context","text":"CoreShop Country Context For CoreShop to determine the current country the visitor or customer comes from, it uses a concept called context and context resolver. Context Name Priority Tag Description FixedCountryContext default coreshop.context.country Used for testing purposes CountryContext default coreshop.context.country Check for a country within the country request resolver StoreAwareCountryContext default coreshop.context.country Check if current country is available in current store context Resolver Name Priority Tag Description GeoLiteBasedRequestResolver 10 coreshop.context.country.request_based.resolver This Resolver tries to determinate the users location by using the Geo Lite Database. These resolver takes care about finding the correct country for the current request. Create a Custom Resolver A Country Context needs to implement the interface CoreShop\\Component\\Address\\Context\\CountryContextInterface. This interface consists of one method called getCountry which returns a CoreShop\\Component\\Address\\Model\\CountryInterface or throws an CoreShop\\Component\\Address\\Context\\CountryNotFoundException. To register your context, you need to use the tag: coreshop.context.country with an optional priority attribute. Create a Request based Resolver CoreShop already implements Request based country context resolver. So if your Context depends on the current request, you can create a custom RequestBased Resolver. To do that, implement the interface CoreShop\\Component\\Address\\Context\\RequestBased\\RequestResolverInterface with the method findCountry. This method either returns a country or null. To register this resolver, use the tag: coreshop.context.country.request_based.resolver with an optional priority attribute. Example We want to a CountryContext to be based on the Pimcore Document. So if we are on site \/de, we want to resolve to Austria, if we are on page \/en we want to resolve to Country Great Britain: 1: First of all we need to create our RequestBased Country Context: &lt;?php namespace AppBundle\\CoreShop\\Address\\Context; use CoreShop\\Component\\Address\\Context\\RequestBased\\RequestResolverInterface; use CoreShop\\Component\\Address\\Repository\\CountryRepositoryInterface; use Pimcore\\Http\\Request\\Resolver\\DocumentResolver; use Symfony\\Component\\HttpFoundation\\Request; final class DocumentBasedRequestRequestResolver implements RequestResolverInterface { \/** * @var DocumentResolver *\/ private $pimcoreDocumentResolver; \/** * @var CountryRepositoryInterface *\/ private $countryRepository; \/** * @param DocumentResolver $pimcoreDocumentResolver * @param CountryRepositoryInterface $countryRepository *\/ public function __construct(DocumentResolver $pimcoreDocumentResolver, CountryRepositoryInterface $countryRepository) { $this-&gt;pimcoreDocumentResolver = $pimcoreDocumentResolver; $this-&gt;countryRepository = $countryRepository; } public function findCountry(Request $request) { $doc = $this-&gt;pimcoreDocumentResolver-&gt;getDocument($request); if (substr($doc-&gt;getFullPath(), 0, 3) === '\/en') { return $this-&gt;countryRepository-&gt;findByCode('GB'); } if (substr($doc-&gt;getFullPath(), 0, 3) === '\/de') { return $this-&gt;countryRepository-&gt;findByCode('AT'); } return null; } } Now we need to configure the service in src\/AppBundle\/Resources\/config\/services.yml services: app.coreshop.country.context.request.document_based: class: AppBundle\\CoreShop\\Address\\Context\\DocumentBasedRequestRequestResolver arguments: - '@Pimcore\\Http\\Request\\Resolver\\DocumentResolver' - '@coreshop.repository.country' tags: - { name: coreshop.context.country.request_based.resolver } CoreShop now tries to resolve the current country based on the Pimcore Site we are on.","tags":"","url":"Development\/Localization\/Countries\/Context.html"},{"title":"States","text":"CoreShop States Create, Update, Read, Delete","tags":"","url":"Development\/Localization\/States\/index.html"},{"title":"CRUD","text":"States Create If you want to create a State via API, you can do following: $newState = $container-&gt;get('coreshop.factory.state')-&gt;createNew(); Now you have a new State, if you want to persist it, you need to do following: $container-&gt;get('coreshop.manager.state')-&gt;persist($newState); $container-&gt;get('coreshop.manager.state')-&gt;flush(); You now have a new persisted State. Read If you want to query for States, you can do following: $stateRepository = $container-&gt;get('coreshop.repository.state'); $queryBuilder = $stateRepository-&gt;createQueryBuilder('c'); \/\/ You can now create your query \/\/ And get the result $states = $queryBuilder-&gt;getQuery()-&gt;getResult(); Update If you want to update and existing State, you need to do following: \/\/ Fetch State $state = $stateRepository-&gt;findById(1); $state-&gt;setName('Euro'); \/\/ And Persist it $container-&gt;get('coreshop.manager.state')-&gt;persist($state); $container-&gt;get('coreshop.manager.state')-&gt;flush(); Delete If you want to update and existing State, you need to do following: \/\/ Fetch State $state = $stateRepository-&gt;findById(1); \/\/ And Persist it $container-&gt;get('coreshop.manager.state')-&gt;remove($state); $container-&gt;get('coreshop.manager.state')-&gt;flush();","tags":"","url":"Development\/Localization\/States\/CRUD.html"},{"title":"Zones","text":"CoreShop Zones Create, Update, Read, Delete","tags":"","url":"Development\/Localization\/Zones\/index.html"},{"title":"CRUD","text":"Zones Create If you want to create a Zone via API, you can do following: $newZone = $container-&gt;get('coreshop.factory.zone')-&gt;createNew(); Now you have a new Zone, if you want to persist it, you need to do following: $container-&gt;get('coreshop.manager.zone')-&gt;persist($newZone); $container-&gt;get('coreshop.manager.zone')-&gt;flush(); You now have a new persisted Zone. Read If you want to query for Zones, you can do following: $zoneRepository = $container-&gt;get('coreshop.repository.zone'); $queryBuilder = $zoneRepository-&gt;createQueryBuilder('c'); \/\/ You can now create your query \/\/ And get the result $zones = $queryBuilder-&gt;getQuery()-&gt;getResult(); Update If you want to update and existing Zone, you need to do following: \/\/ Fetch Zone $zone = $zoneRepository-&gt;findById(1); $zone-&gt;setName('Euro'); \/\/ And Persist it $container-&gt;get('coreshop.manager.zone')-&gt;persist($zone); $container-&gt;get('coreshop.manager.zone')-&gt;flush(); Delete If you want to update and existing Zone, you need to do following: \/\/ Fetch Zone $zone = $zoneRepository-&gt;findById(1); \/\/ And Persist it $container-&gt;get('coreshop.manager.zone')-&gt;remove($zone); $container-&gt;get('coreshop.manager.zone')-&gt;flush();","tags":"","url":"Development\/Localization\/Zones\/CRUD.html"},{"title":"Taxes","text":"CoreShop Taxes Taxes are divided into Tax Rates and Tax Rules. Tax Rules are responsible for the real Tax Rate determination based on Country and State. Tax Rates Tax Rules","tags":"","url":"Development\/Localization\/Taxes\/index.html"},{"title":"Tax Rate","text":"CoreShop Tax Rate The Tax Rate only represents a single Tax Rate Number. For example: 20%. Create, Update, Read, Delete","tags":"","url":"Development\/Localization\/Taxes\/Tax_Rate\/index.html"},{"title":"CRUD","text":"Tax Rates Create If you want to create a Zone via API, you can do following: $newZone = $container-&gt;get('coreshop.factory.tax_rate')-&gt;createNew(); Now you have a new Zone, if you want to persist it, you need to do following: $container-&gt;get('coreshop.manager.tax_rate')-&gt;persist($newZone); $container-&gt;get('coreshop.manager.tax_rate')-&gt;flush(); You now have a new persisted Zone. Read If you want to query for Tax Rates, you can do following: $rateRepository = $container-&gt;get('coreshop.repository.tax_rate'); $queryBuilder = $rateRepository-&gt;createQueryBuilder('c'); \/\/ You can now create your query \/\/ And get the result $rates = $queryBuilder-&gt;getQuery()-&gt;getResult(); Update If you want to update and existing Zone, you need to do following: \/\/ Fetch Zone $rate = $rateRepository-&gt;findById(1); $rate-&gt;setName('Euro'); \/\/ And Persist it $container-&gt;get('coreshop.manager.tax_rate')-&gt;persist($rate); $container-&gt;get('coreshop.manager.tax_rate')-&gt;flush(); Delete If you want to update and existing Zone, you need to do following: \/\/ Fetch Zone $rate = $rateRepository-&gt;findById(1); \/\/ And Persist it $container-&gt;get('coreshop.manager.tax_rate')-&gt;remove($rate); $container-&gt;get('coreshop.manager.tax_rate')-&gt;flush();","tags":"","url":"Development\/Localization\/Taxes\/Tax_Rate\/CRUD.html"},{"title":"Tax Rule","text":"CoreShop Tax Rule The Tax Rule handles different Taxes based on Country and State. Create, Update, Read, Delete","tags":"","url":"Development\/Localization\/Taxes\/Tax_Rule\/index.html"},{"title":"CRUD","text":"Tax Rules Create If you want to create a Tax Rule via API, you can do following: $newTaxRule = $container-&gt;get('coreshop.factory.tax_rule')-&gt;createNew(); Now you have a new Tax Rule, if you want to persist it, you need to do following: $container-&gt;get('coreshop.manager.tax_rule')-&gt;persist($newTaxRule); $container-&gt;get('coreshop.manager.tax_rule')-&gt;flush(); You now have a new persisted Tax Rule. Read If you want to query for Tax Rules, you can do following: $ruleRepository = $container-&gt;get('coreshop.repository.tax_rule'); $queryBuilder = $ruleRepository-&gt;createQueryBuilder('c'); \/\/ You can now create your query \/\/ And get the result $rules = $queryBuilder-&gt;getQuery()-&gt;getResult(); Update If you want to update and existing Tax Rule, you need to do following: \/\/ Fetch Tax Rule $rule = $ruleRepository-&gt;findById(1); $rule-&gt;setName('Euro'); \/\/ And Persist it $container-&gt;get('coreshop.manager.tax_rule')-&gt;persist($rule); $container-&gt;get('coreshop.manager.tax_rule')-&gt;flush(); Delete If you want to update and existing Tax Rule, you need to do following: \/\/ Fetch Tax Rule $rule = $ruleRepository-&gt;findById(1); \/\/ And Persist it $container-&gt;get('coreshop.manager.tax_rule')-&gt;remove($rule); $container-&gt;get('coreshop.manager.tax_rule')-&gt;flush();","tags":"","url":"Development\/Localization\/Taxes\/Tax_Rule\/CRUD.html"},{"title":"Tax Factory","text":"","tags":"","url":"Development\/Localization\/Taxes\/Tax_Rule\/Tax_Factory.html"},{"title":"Products","text":"CoreShop Products This guide should lead you through how CoreShop handles Product information and how it does price calculations. Create, Read, Update, Delete Price Calculation Price Rules Configuration Multiple Product DataObjects Product Units Product Unit Definitions","tags":"","url":"Development\/Products\/index.html"},{"title":"CRUD","text":"CoreShop Product CoreShop uses Pimcore Data Objects to persist Product Information. But, it adds a little wrapper around it to be more dynamic and configurable. It uses a Factory and Repository Pattern to do that. Create If you want to create a new Product, we need to get our Factory Service for that: $productFactory = $container-&gt;get('coreshop.factory.product'); $product = $productFactory-&gt;createNew(); No we have our product and we can set all needed values. If you now want to save it, just call the save function $product-&gt;save(); Read To get products, you need to use the Repository Service CoreShop provides you. $repository = $container-&gt;get('coreshop.repository.product'); \/\/ Query by ID $productWithIdOne = $repository-&gt;findById(1); \/\/ Get a Listing how you know it from Pimcore $list = $repository-&gt;getList(); $list-&gt;setCondition(&quot;active = 1&quot;); $products = $list-&gt;getObjects(); Update Update works the same as you are used to in Pimcore $repository = $container-&gt;get('coreshop.repository.product'); \/\/ Query by ID $productWithIdOne = $repository-&gt;findById(1); \/\/ Change values $productWithIdOne-&gt;setName('test'); $productWithIdOne-&gt;save(); Delete Delete works the same as you are used to in Pimcore $repository = $container-&gt;get('coreshop.repository.product'); \/\/ Query by ID $productWithIdOne = $repository-&gt;findById(1); $productWithIdOne-&gt;delete();","tags":"","url":"Development\/Products\/CRUD.html"},{"title":"Price Calculation","text":"CoreShop Product Price Calculation CoreShop uses multiple Price Calculators to determine the correct price for a product. Per default following Calculators are used Price Rule Calculator which uses Prices from Catalog Price Rules and Specific Price Rules Store Product Price Calculator These two are only the default implementations, if you need a custom Calculator, you need to implement the Interface CoreShop\\Component\\Product\\Calculator\\ProductPriceCalculatorInterface and register your service with the tag coreshop.product.price_calculator, a type attribute and a priority What prices does CoreShop calculate? CoreShop Price Calculation consists of 3 different prices: Retail Price: Base Price without any discounts Discount Price: Special Price for promotions. Needs to return a price smaller than retail price, otherwise retail price is valid Discount: Discount from promotions Price: Retail Price or Discount Price (if available) minus discount rules The default is always to use store values prices. Calculator Service If you want to calculate the Price for a Product, you need to use a special service to do that. There are two options: 1: coreshop.product.price_calculator which calculates prices without any tax regards. 2: coreshop.product.taxed_price_calculator which calculates prices with tax or without. (recommended one to use) Templating If you want to calculate the price within a Template, you can do so by using the filter coreshop_product_price {{ (product|coreshop_product_price(true)) }} Custom Price Calculator Example Our Example Service will take the Property &quot;price&quot; - 1 as Product Price and -1 as Discount, therefore the price stays the same. This example is only a show-case of how to add a new calculator. CoreShop Price calculation always depends on a context. The context per default consists of following values: Store Country Currency Customer (if logged in) Cart &lt;?php namespace AppBundle\\CoreShop\\Product; use CoreShop\\Component\\Product\\Calculator\\ProductPriceCalculatorInterface; use CoreShop\\Component\\Product\\Model\\ProductInterface; final class CustomPriceCalculator implements ProductPriceCalculatorInterface { \/** * Used to determine a retail price *\/ public function getPrice(ProductInterface $subject, array $context, bool $withDiscount = true): int { $price = $this-&gt;getRetailPrice($subject, $context); return $withDiscount ? $this-&gt;getDiscount($subject, $price) : $price; } \/** * Used to determine a retail price *\/ public function getRetailPrice(ProductInterface $subject, array $context): int { return $subject-&gt;getStorePrice($context['store']); } \/** * Used to determine a discount *\/ public function getDiscount(ProductInterface $subject, array $context, int $price): int { return 0; } \/** * Used to determine a discounted price *\/ public function getDiscountPrice(ProductInterface $subject, array $context): int { return 0; } } Now we need to register our service to the container and add the calculator tag: app.coreshop.product.price_calculator.custom: class: AppBundle\\CoreShop\\Product\\CustomPriceCalculator tags: - { name: coreshop.product.price_calculator, type: custom, priority: 1 } CoreShop now uses our service for all Product Price Calculations.","tags":"","url":"Development\/Products\/Price_Calculation.html"},{"title":"Price Rules","text":"CoreShop Product Price Rules CoreShop gives you the ability of very complex price calculation methods. Price Rules always consist of Conditions and Actions. Price Rule Types Product Price Rules Checkout all available product price rules here Product price rules are applied to multiple products based on conditions like category or manufacturer. Specific Price Rules Checkout all available specific price rules here Specific price rules are applied to a single product based on conditions like customer or customer group. Quantity Price Rules Checkout all available quantity price rules here Quantity price rules are applied to a single product based on conditions like the quantity of a cart item. These rules apply only in the calculation of cart item prices. If you have only quantity rules configured, the default price calculation of CoreShop will return zero outside of cart context. Extending Conditions and Actions Click here to see how you can add custom Actions Click here to see how you can add custom Conditions Template Helper Get Formatted Price with all applied Rules {% import '@CoreShopFrontend\/Common\/Macro\/currency.html.twig' as currency %} {% import '@CoreShopFrontend\/Common\/Macro\/product_price.html.twig' as product_price %} &lt;div class=&quot;price&quot;&gt; &lt;span class=&quot;price-head&quot;&gt;{{ 'coreshop.ui.price'|trans }}:&lt;\/span&gt; {{ product_price.display_product_price(product) }} &lt;\/div&gt; &lt;div class=&quot;tax&quot;&gt; {{ 'coreshop_product_tax_inc'|trans|format(product|coreshop_product_tax_rate) }} ({{ currency.convertAndFormat(product|coreshop_product_tax_amount) }}) &lt;\/div&gt; Get Active Price Rules {{ dump(product|coreshop_product_price_rules) }}","tags":"","url":"Development\/Products\/Price_Rules\/index.html"},{"title":"Configuration","text":"CoreShop Product Configuration core_shop_product: pimcore: product: path: coreshop\/products classes: repository: CoreShop\\Bundle\\CoreBundle\\Pimcore\\Repository\\ProductRepository install_file: '@CoreShopCoreBundle\/Resources\/install\/pimcore\/classes\/CoreShopProductBundle\/CoreShopProduct.json' model: Pimcore\\Model\\DataObject\\CoreShopProduct interface: CoreShop\\Component\\Product\\Model\\ProductInterface factory: CoreShop\\Component\\Resource\\Factory\\PimcoreFactory type: object","tags":"","url":"Development\/Products\/Configuration.html"},{"title":"Multiple Product DataObjects","text":"CoreShop Multiple Product DataObjects CoreShop comes with one pre-installed Product Class (CoreShopProduct), which in most cases is enough. In some cases, you might want to use separated classes with different purposes. For example a ProductSet, which consists of multiple Products but also needs to be available for complex price calculations like Price Rules. First of all, we need to create a new DataObject Class in Pimcore. A basic Purchasable Product only needs to implement \\CoreShop\\Component\\Order\\Model\\PurchasableInterface but since we want to allow complex price calculation, we need to implement CoreShop\\Component\\Core\\Model\\ProductInterface. Note If your Product is very simple and you do not need complex price calculations you then only need to implement \\CoreShop\\Component\\Order\\Model\\PurchasableInterface Easiest way to create the new class is: 1: Open Pimcore DataObject Editor 2: Add a new Class called ProductSet 3: Import CoreShop Default Product Class (CoreShopProduct.json) 4: Adapt to your needs 5: Register your ProductSet Class to CoreShop: &lt;?php \/\/src\/AppBundle\/DependencyInjection\/Configuration.php namespace AppBundle\\DependencyInjection; use CoreShop\\Bundle\\ProductBundle\\Pimcore\\Repository\\ProductRepository; use CoreShop\\Bundle\\ResourceBundle\\CoreShopResourceBundle; use CoreShop\\Component\\Product\\Model\\ProductInterface; use CoreShop\\Component\\Resource\\Factory\\PimcoreFactory; use Symfony\\Component\\Config\\Definition\\Builder\\ArrayNodeDefinition; use Symfony\\Component\\Config\\Definition\\Builder\\TreeBuilder; use Symfony\\Component\\Config\\Definition\\ConfigurationInterface; final class Configuration implements ConfigurationInterface { public function getConfigTreeBuilder() { $treeBuilder = new TreeBuilder(); $rootNode = $treeBuilder-&gt;root('app'); $rootNode -&gt;children() -&gt;scalarNode('driver')-&gt;defaultValue(CoreShopResourceBundle::DRIVER_DOCTRINE_ORM)-&gt;end() -&gt;end() ; $this-&gt;addModelsSection($rootNode); return $treeBuilder; } \/\/Add your configuration here private function addModelsSection(ArrayNodeDefinition $node) { $node -&gt;children() -&gt;arrayNode('pimcore') -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;arrayNode('product_set') -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;variableNode('options')-&gt;end() -&gt;scalarNode('path')-&gt;defaultValue('products')-&gt;end() -&gt;arrayNode('classes') -&gt;addDefaultsIfNotSet() -&gt;children() -&gt;scalarNode('model')-&gt;defaultValue('Pimcore\\Model\\DataObject\\ProductSet')-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('interface')-&gt;defaultValue(ProductInterface::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('factory')-&gt;defaultValue(PimcoreFactory::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('repository')-&gt;defaultValue(ProductRepository::class)-&gt;cannotBeEmpty()-&gt;end() -&gt;scalarNode('install_file')-&gt;defaultValue('@CoreShopProductBundle\/Resources\/install\/pimcore\/classes\/CoreShopProduct.json')-&gt;end() -&gt;scalarNode('type')-&gt;defaultValue(CoreShopResourceBundle::PIMCORE_MODEL_TYPE_OBJECT)-&gt;cannotBeOverwritten(true)-&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() -&gt;end() ; } } &lt;?php \/\/src\/AppBundle\/DependencyInjection\/AppExtension.php namespace AppBundle\\DependencyInjection; use CoreShop\\Bundle\\ResourceBundle\\DependencyInjection\\Extension\\AbstractModelExtension; use Symfony\\Component\\Config\\FileLocator; use Symfony\\Component\\DependencyInjection\\ContainerBuilder; use Symfony\\Component\\DependencyInjection\\Loader\\YamlFileLoader; class AppExtension extends AbstractModelExtension { public function load(array $config, ContainerBuilder $container) { $config = $this-&gt;processConfiguration($this-&gt;getConfiguration([], $container), $config); $loader = new YamlFileLoader($container, new FileLocator(__DIR__.'\/..\/Resources\/config')); \/\/Register the model to the container $this-&gt;registerPimcoreModels('app', $config['pimcore'], $container); \/\/Alternative you can do it manually like: $this-&gt;registerPimcoreModels('app', [ 'product_set' =&gt; [ 'path' =&gt; '\/product-sets', 'classes' =&gt; [ 'model' =&gt; 'Pimcore\\Model\\DataObject\\ProductSet', 'interface' =&gt; ProductInterface::class, 'factory' =&gt; PimcoreFactory::class, 'type' =&gt; CoreShopResourceBundle::PIMCORE_MODEL_TYPE_OBJECT ] ] ], $container); $loader-&gt;load('services.yml'); } } 6: You can now use the new ObjectClass as you wish, CoreShop automatically recognises it as ProductClass and your are allowed to use it in PriceRules. Note: For the Class to be allowed as href\/multihref in Pimcore, you need to adapt following classes as well: CoreShopCartItem CoreShopOrderItem CoreShopQuoteItem Check for the product field and add your new ProductSet there as allowed references.","tags":"","url":"Development\/Products\/Multiple_Product_DataObjects.html"},{"title":"Units","text":"CoreShop Product Units Units for Products can be defined globally in the Pimcore Backend on CoreShopMenu &gt; Product &gt; Product Units. Each Product can have different units. Also each product\/unit relation can have an own precision that differs to other relations. To archive that, the relation between products and units consists of three objects: ProductUnit ProductUnitDefinition ProductUnitDefinitions As already said, the ProductUnit can be created in Pimcore Backend and consists mainly of the key for unit like PCS, CNT etc. and some localized fields for rendering in frontend. To connect a ProductUnit to a CoreShopProduct in Backend you need to get the ProductUnit via repository and create a ProductUnitDefinition. use CoreShop\\Component\\Product\\Model\\Product; use CoreShop\\Component\\Product\\Model\\ProductUnitInterface; use CoreShop\\Component\\Product\\Model\\ProductUnitDefinition; $product = Product::getById(1); \/** @var ProductUnitInterface $unit *\/ $unit = $this-&gt;unitRepository-&gt;findOneBy(['name' =&gt; '']); $unitDefinition = new ProductUnitDefinition(); $unitDefinition-&gt;setConversionRate(1.0); \/\/ optional $unitDefinition-&gt;setPrecision(0); \/\/ optional $unitDefinition-&gt;setUnit($unit); $product-&gt;getUnitDefinitions()-&gt;setDefaultUnitDefinition($unitDefinition); $product-&gt;save(); To add multiple units for a product use $product-&gt;addUnitDefinition($unitDefinition). To change a unit override the default one $product-&gt;getUnitDefinitions()-&gt;getDefaultUnitDefinition()-&gt;setUnit($otherUnit).","tags":"","url":"Development\/Products\/Units.html"},{"title":"Unit Definitions","text":"CoreShop Product Unit Definitions CoreShop has a great new feature for product units. E.g. you can sell items &quot;per meter&quot; etc. First, add some product units in Pimcore &gt; CoreShop &gt; Product &gt; Product Units. Click &quot;Add&quot; and fill all the fields. Then you can add product-units directly in the product-objects inside Pimcore (take a look at the &quot;Price&quot;-tab). There, you can also add multiple product units (eg: 1 box contains of 12 items - CoreShop will show you different order-possibilities in the add-to-cart section in the webshop) Using the API for product units: Create Default UnitDefinition If you want to create a new Product, we need to get our Factory Service for that: \/** @var DataObject\\CoreShopProduct $product *\/ $product = DataObject::getById(1); $unitRepository = $container-&gt;get('coreshop.repository.product_unit'); \/** @var ProductUnitDefinitionInterface $defaultUnitDefinition *\/ $defaultUnitDefinition = $container-&gt;get('coreshop.factory.product_unit_definition')-&gt;createNew(); $defaultUnitDefinition-&gt;setUnit($unitRepository-&gt;findByName('Kubikmeter')); \/** @var ProductUnitDefinitionsInterface $unitDefinitions *\/ $unitDefinitions = $container-&gt;get('coreshop.factory.product_unit_definitions')-&gt;createNew(); $unitDefinitions-&gt;setDefaultUnitDefinition($defaultUnitDefinition); $unitDefinitions-&gt;setProduct($product); $product-&gt;setUnitDefinitions($unitDefinitions); $product-&gt;save(); Update Default UnitDefinition \/** @var DataObject\\CoreShopProduct $product *\/ $product = DataObject::getById(1); $unitRepository = $container-&gt;get('coreshop.repository.product_unit'); $defaultUnitDefinition = $product-&gt;getUnitDefinitions()-&gt;getDefaultUnitDefinition(); $defaultUnitDefinition-&gt;setUnit($unitRepository-&gt;findByName('Liter')); $unitDefinitionsRepository = $container-&gt;get('coreshop.repository.product_unit_definitions'); \/** @var ProductUnitDefinitions $unitDefinitions *\/ $unitDefinitions = $unitDefinitionsRepository-&gt;findOneForProduct($product); $unitDefinitions-&gt;setDefaultUnitDefinition($defaultUnitDefinition); $product-&gt;setUnitDefinitions($unitDefinitions); $product-&gt;save(); Delete UnitDefinition Deleting a UnitDefiniton from a product is done by finding the UnitDefinitions for the product in the product_unit_definitions repository and then deleting it. \/** @var DataObject\\CoreShopProduct $product *\/ $product = DataObject::getById(1); $unitDefinitionsRepository = $container-&gt;get('coreshop.repository.product_unit_definitions'); $item = $unitDefinitionsRepository-&gt;findOneForProduct($product); $unitDefinitionsRepository-&gt;remove($item);","tags":"","url":"Development\/Products\/Unit_Definitions.html"},{"title":"Cart","text":"CoreShop Cart This guide should lead you through how CoreShop handles the Cart. Create, Read, Update, Delete Cart Manager Cart Modifier Cart Processor Commands Cart Context Introduction The CoreShop Cart is stateless. Which means that every change on the cart triggers the Cart Processor which then calculates all necessary prices.","tags":"","url":"Development\/Cart\/index.html"},{"title":"CRUD","text":"CoreShop Cart CoreShop uses Pimcore Data Objects to persist Cart Information. But, it adds a little wrapper around it to be mire dynamic and configurable. It uses a Factory and Repository Pattern to do that. Create If you want to create a new Cart, we need to get our Factory Service for that: $factory = $container-&gt;get('coreshop.factory.cart'); $cart = $factory-&gt;createNew(); No we have a new Cart and we can set all needed values. If you now want to save it, just call the save function $cart-&gt;save(); Read To get carts, you need to use the Repository Service CoreShop provides you. $repository = $container-&gt;get('coreshop.repository.cart'); \/\/ Query by ID $cartWithIdOne = $repository-&gt;findById(1); \/\/ Get a Listing how you know it from Pimcore $list = $repository-&gt;getList(); $list-&gt;setCondition(&quot;total &gt; 100&quot;); $carts = $list-&gt;getObjects(); Update Update works the same as you are used to in Pimcore $repository = $container-&gt;get('coreshop.repository.cart'); \/\/ Query by ID $cartWithIdOne = $repository-&gt;findById(1); \/\/ Change values $cartWithIdOne-&gt;setCustomer($customer); $cartWithIdOne-&gt;save(); Delete Delete works the same as you are used to in Pimcore $repository = $container-&gt;get('coreshop.repository.cart'); \/\/ Query by ID $cartWithIdOne = $repository-&gt;findById(1); $cartWithIdOne-&gt;delete();","tags":"","url":"Development\/Cart\/CRUD.html"},{"title":"Cart Manager","text":"CoreShop Cart Manager The Cart Manager helps you managing Carts. It handles: Persisting a Cart The Cart Manager implements the Interface CoreShop\\Component\\Order\\Manager\\CartManagerInterface and is implemented in the Service coreshop.cart.manager:","tags":"","url":"Development\/Cart\/Cart_Manager.html"},{"title":"Cart Modifier","text":"CoreShop Cart Modifier CoreShop provides you with a helper service to modify the cart. It handles following for you: adding items removing items change quantity of items The Modifier implements the interface CoreShop\\Component\\Order\\Cart\\CartModifierInterface and is implemented by the service coreshop.cart.modifier The Cart Modifier itself, uses the Storage List Component","tags":"","url":"Development\/Cart\/Cart_Modifier.html"},{"title":"Cart Processor","text":"CoreShop Cart Processor The Cart Processor takes care about refreshing the state and prices of carts for you. Everytime the persistCart function of the Cart-Manager is called on a Cart, it gets triggered and re-calculates the cart. Following Processors are implemented by default: Cart Adjustment Clearer Item Processor Item Tax Processor Cart Price Rule Voucher Processor Cart Rule Auto Processor Cart Shipping Processor Cart Tax Processor These Processors calculate all necessary prices of the cart. If you need to extend the Cart and change calculations, you need to create a new Processor. Creating a Cart Processor A Cart Processor needs to implement the Interface CoreShop\\Component\\Order\\Processor\\CartProcessorInterface and registered into the container with the tag coreshop.cart_processor and a priority attribute. Example of a Cart Processor For example, we create a Cart Processor, which calculates a custom field in our Cart. &lt;?php namespace AppBundle\\CoreShop\\Order\\Cart\\Processor; use CoreShop\\Component\\Order\\Model\\OrderInterface; use CoreShop\\Component\\Order\\Processor\\CartProcessorInterface; final class CustomCartProcessor implements CartProcessorInterface { public function process(OrderInterface $cart): void { $cart-&gt;setCustomField(uniqid()); } } We now only need to register the class: app.coreshop.cart.processor.custom: class: AppBundle\\CoreShop\\Order\\Cart\\Processor\\CustomCartProcessor tags: - { name: coreshop.cart_processor, priority: 200 } On every Cart Update, our service now gets called a the custom field gets a new unique id.","tags":"","url":"Development\/Cart\/Cart_Processor.html"},{"title":"Commands","text":"CoreShop Cart Commands Expire Abandoned Carts # Delete only anonymous carts $ bin\/console coreshop:cart:expire --anonymous # Delete only user carts $ bin\/console coreshop:cart:expire --user # Delete carts older than 20 days $ bin\/console coreshop:cart:expire --days=20 Expire Abandoned Carts via Maintenance Mode By default, this feature is disabled. If you want to swipe abandoned carts by default you need to define a expiration date: core_shop_order: expiration: cart: days: 20 anonymous: true customer: true Read more about automation here.","tags":"","url":"Development\/Cart\/Commands.html"},{"title":"Context","text":"CoreShop Cart Context For CoreShop to determine the current cart it uses a concept called context and context resolver. The Cart Context implements the Interface CoreShop\\Component\\Order\\Context\\CartContextInterface and is implemented in the Service coreshop.context.cart: Getting the current Cart If you want to get the current cart, you simply use the service: $cartContext = $container-&gt;get('coreshop.context.cart'); \/\/ Get current cart, if none exists, it creates a new one $cart = $cartContext-&gt;getCart(); Context Name Priority Description FixedCartContext -100 Used for testing purposes or for backend order creation SessionAndStoreBasedCartContext -555 Search for a valid session cart in given store context CustomerAndStoreBasedCartContext -777 Search for a cart based on a customer. Note: This context only triggers after a user has been successfully logged in. It searches for the last available cart a user may has left. CartContext -999 If all other context classes failed finally this context will create a fresh cart Create a Custom Resolver To register your context, you need to use the tag: coreshop.context.cart with an optional priority attribute.","tags":"","url":"Development\/Cart\/Context.html"},{"title":"Checkout","text":"CoreShop Checkout This guide should lead you through how CoreShop handles the Checkout. Checkout Manager Checkout Step","tags":"","url":"Development\/Checkout\/index.html"},{"title":"Checkout Manager","text":"CoreShop Checkout Manager CoreShop Checkout CoreShop uses a CheckoutManager to handle Checkout steps. The default installation comes with following Steps: Cart Customer Address Shipping Payment Summary Create a Custom CheckoutManager If you want to modify the Checkout Manager, you have two options: Create a total different Checkout Manager configuration Modify the default configuration Create a total different Checkout Manager # app\/config\/config.yml core_shop_core: checkout_manager: my_custom_manager checkout: my_custom_manager: steps: customer: step: coreshop.checkout.step.customer priority: 10 address: step: coreshop.checkout.step.address priority: 20 shipping: step: coreshop.checkout.step.shipping priority: 30 payment: step: coreshop.checkout.step.payment priority: 40 summary: step: coreshop.checkout.step.summary priority: 50 Modify the default configuration # app\/config\/config.yml core_shop_core: checkout: default: steps: payment: false # disables the payment step shipping: false # disables the shipping step payment_shipping: # adds a new PaymentShiping Step step: app_bundle.coreshop.checkout.payment_shipping # This is your service-id, the service needs to implement CoreShop\\Component\\Order\\Checkout\\CheckoutStepInterface priority: 40 # Priority of this step","tags":"","url":"Development\/Checkout\/Checkout_Manager.html"},{"title":"Checkout Step","text":"CoreShop Checkout Step If you want to implement a custom checkout step, you need to implement the interface CoreShop\\Component\\Order\\Checkout\\CheckoutStepInterface and register your step into your Cart Manager: # app\/config\/config.yml core_shop_core: checkout: default: steps: custom: step: app.coreshop.checkout.custom priority: 50 The Checkout Controller takes care about handling the Checkout for you then. Optional Checkout Step If you have an optional checkout step - depending on the cart, your Checkout Step can implement the interface CoreShop\\Component\\Order\\Checkout\\OptionalCheckoutStepInterface. You need to implement the function isRequired(OrderInterface $cart) Optional Checkout Step Example &lt;?php namespace CoreShop\\Bundle\\CoreBundle\\Checkout\\Step; use CoreShop\\Bundle\\CoreBundle\\Form\\Type\\Checkout\\PaymentType; use CoreShop\\Component\\Order\\Checkout\\CheckoutException; use CoreShop\\Component\\Order\\Checkout\\CheckoutStepInterface; use CoreShop\\Component\\Order\\Checkout\\OptionalCheckoutStepInterface; use CoreShop\\Component\\Order\\Checkout\\ValidationCheckoutStepInterface; use CoreShop\\Component\\Order\\Manager\\CartManagerInterface; use CoreShop\\Component\\Order\\Model\\OrderInterface; use CoreShop\\Component\\Payment\\Model\\PaymentProviderInterface; use CoreShop\\Component\\Store\\Context\\StoreContextInterface; use Symfony\\Component\\Form\\FormFactoryInterface; use Symfony\\Component\\HttpFoundation\\Request; class PaymentCheckoutStep implements CheckoutStepInterface, OptionalCheckoutStepInterface, ValidationCheckoutStepInterface { private FormFactoryInterface $formFactory; private StoreContextInterface $storeContext; private CartManagerInterface $cartManager; public function __construct( FormFactoryInterface $formFactory, StoreContextInterface $storeContext, CartManagerInterface $cartManager ) { $this-&gt;formFactory = $formFactory; $this-&gt;storeContext = $storeContext; $this-&gt;cartManager = $cartManager; } public function getIdentifier(): string { return 'payment'; } public function doAutoForward(OrderInterface $cart): bool { return $cart-&gt;getTotal() &gt; 0; } public function doAutoForward(OrderInterface $cart): bool { return false; } public function validate(OrderInterface $cart): bool { return $cart-&gt;hasItems() &amp;&amp; $cart-&gt;getPaymentProvider() instanceof PaymentProviderInterface; } public function commitStep(OrderInterface $cart, Request $request): bool { $form = $this-&gt;createForm($request, $cart); if ($form-&gt;isSubmitted()) { if ($form-&gt;isValid()) { $cart = $form-&gt;getData(); $this-&gt;cartManager-&gt;persistCart($cart); return true; } else { throw new CheckoutException('Payment Form is invalid', 'coreshop.ui.error.coreshop_checkout_payment_form_invalid'); } } return false; } public function prepareStep(OrderInterface $cart, Request $request): array { return [ 'form' =&gt; $this-&gt;createForm($request, $cart)-&gt;createView(), ]; } private function createForm(Request $request, OrderInterface $cart) { $form = $this-&gt;formFactory-&gt;createNamed('', PaymentType::class, $cart, [ 'payment_subject' =&gt; $cart ]); if ($request-&gt;isMethod('post')) { $form = $form-&gt;handleRequest($request); } return $form; } }","tags":"","url":"Development\/Checkout\/Checkout_Step.html"},{"title":"Order","text":"CoreShop Order This guide should lead you through how CoreShop handles Orders. Order Creation Transformer Order Workflow Invoice Shipment Template\/Twig Helper Extend Order with additional data CoreShop Order List Order List: Add Custom Filter Order List: Add Custom Actions","tags":"","url":"Development\/Order\/index.html"},{"title":"Order Creation","text":"CoreShop Order Creation Orders are usually getting created through the Checkout Step. If you ever need to create an Order manually, there are multiple ways. Order CRUD You can always use the Pimcore API to create Orders, in CoreShop you would do it through the Factory: $factory = $container-&gt;get('coreshop.factory.order')-&gt;createNew(); You can now fill the Order with all necessary information. The more usual way to create Orders is through Carts or Quotes. Therefore CoreShop implements Transformer for that.","tags":"","url":"Development\/Order\/Order_Creation.html"},{"title":"Transformer","text":"CoreShop Transfomers Transfomers, as the name say, transform Data from different formats. A transformer converts between Object Types. For example: Cart -&gt; Order. Following implementation do exist right now: an Order into an Invoice an Order into an Shipment The base transformer interface for all &quot;Proposals&quot; is CoreShop\\Component\\Order\\Transformer\\ProposalTransformerInterface Extending Transfomers If you ever have the need to adapt the transfomer, eg. hook into it and store some custom data into the order, you can do so by decorating the default service. Following Services are used by CoreShop for all different Transfomers: From To Service Order Invoice coreshop.order.transformer.order_to_invoice OrderItem InvoiceItem coreshop.order_invoice.transformer.cart_item_to_order_item Order Shipment coreshop.order.transformer.order_to_invoice OrderItem ShipmentItem coreshop.order_invoice.transformer.order_item_to_shipment_item","tags":"","url":"Development\/Order\/Transformer.html"},{"title":"Order Workflow","text":"CoreShop Order Workflow CoreShop uses Symfony Workflow to apply states. Here is the detail information about the State Machine.","tags":"","url":"Development\/Order\/Order_Workflow.html"},{"title":"Invoice","text":"CoreShop Invoice CoreShop comes with an Invoice creation feature. This means, it can create Invoices for Orders based on Workflow States.","tags":"","url":"Development\/Order\/Invoice\/index.html"},{"title":"Invoice Creation","text":"CoreShop Invoice Creation See Order Transformer for more. Add a Invoice to an Order \/** * Note: * * The TRANSITION_REQUEST_INVOICE transition can only be applied once. * Only dispatch it with the creation of the first invoice. * This transition will inform the order invoice workflow that it's ready to initiate the invoice processing. *\/ $workflow = $this-&gt;getStateMachineManager()-&gt;get($order, 'coreshop_order_invoice'); $workflow-&gt;apply($order, OrderInvoiceTransitions::TRANSITION_REQUEST_INVOICE); $order = ''; \/** @var InvoiceInterface $invoice *\/ $invoice = $this-&gt;container-&gt;get('coreshop.factory.order_invoice')-&gt;createNew(); $invoice-&gt;setState(InvoiceStates::STATE_NEW); $items = []; $invoice = $this-&gt;get('coreshop.order.transformer.order_to_invoice')-&gt;transform($order, $invoice, $items);","tags":"","url":"Development\/Order\/Invoice\/Invoice_Creation.html"},{"title":"Purchasable","text":"CoreShop Order Purchasable Items, you want to add to your Cart\/Order\/Quote, need to implement CoreShop\\Component\\Order\\Model\\PurchasableInterface. The concept of Purchasable allows us to decouple CoreShops Order Component from the Product Component and makes the Cart\/Quote\/Order more flexible in ways of which object types can be used. A Purchasable does not a have Price directly You need create a class that implements CoreShop\\Component\\Order\\Calculator\\PurchasablePriceCalculatorInterface. in order to calculate price Implementation of a new Purchasable Price Calculator To implement a new custom Purchasable Price Calculator, you need to implement the interface CoreShop\\Component\\Order\\Calculator\\PurchasablePriceCalculatorInterface. As an example, we create a ProductSetCalculator, which takes prices of each consisting Product: &lt;?php namespace AppBundle\\CoreShop\\Order\\Calculator; use CoreShop\\Component\\Order\\Calculator\\PurchasablePriceCalculatorInterface; use CoreShop\\Component\\Order\\Exception\\NoPurchasablePriceFoundException;use CoreShop\\Component\\Order\\Model\\PurchasableInterface; use Pimcore\\Model\\Product\\ProductSet; final class ProductSetCalculator implements PurchasablePriceCalculatorInterface { private PurchasablePriceCalculatorInterface $purchasablePriceCalculator; public function __construct(PurchasablePriceCalculatorInterface $purchasablePriceCalculator) { $this-&gt;purchasablePriceCalculator = $purchasablePriceCalculator; } public function getPrice(PurchasableInterface $purchasable, array $context, bool $includingDiscounts = false): int { if ($purchasable instanceof ProductSet) { $price = 0; foreach ($purchasable-&gt;getProducts() as $product) { $price .= $this-&gt;purchasablePriceCalculator-&gt;getPrice($product); } return $price; } throw new NoPurchasablePriceFoundException($this); } } Now we need to register our Service to the Container: app.coreshop.order.purchasable.price_calculator.product_set: class: AppBundle\\CoreShop\\Order\\Calculator\\ProductSetCalculator arguments: - '@coreshop.order.purchasable.price_calculator' tags: - { name: coreshop.order.purchasable.price_calculator, type: product_set, priority: 20 }","tags":"","url":"Development\/Order\/Purchasable.html"},{"title":"Shipment","text":"CoreShop Shipment CoreShop comes with an Shipment (Delivery Slip) creation feature. This means, it can create Shipments for Orders based on Workflow States.","tags":"","url":"Development\/Order\/Shipment\/index.html"},{"title":"Shipment Creation","text":"CoreShop Shipment Creation See Order Transformer for more. Add a Shipment to an Order \/** * Note: * * The TRANSITION_REQUEST_SHIPMENT transition can only be applied once. * Only dispatch it with the creation of the first shipment. * This transition will inform the order shipment workflow that it's ready to initiate the shipment processing. *\/ $workflow = $this-&gt;getStateMachineManager()-&gt;get($order, 'coreshop_order_shipment'); $workflow-&gt;apply($order, OrderShipmentTransitions::TRANSITION_REQUEST_SHIPMENT); $order = ''; \/** @var ShipmentInterface $shipment *\/ $shipment = $this-&gt;container-&gt;get('coreshop.factory.order_shipment')-&gt;createNew(); $shipment-&gt;setState(ShipmentStates::STATE_NEW); $items = []; $shipment = $this-&gt;get('coreshop.order.transformer.order_to_shipment')-&gt;transform($order, $shipment, $items);","tags":"","url":"Development\/Order\/Shipment\/Shipment_Creation.html"},{"title":"Filter","text":"CoreShop Order List Filter This comes in handy if you need some special filtered data in your Order List. Your Customer is able to filter orders on specific conditions. Register Filter Service AppBundle\\CoreShop\\OrderList\\Filter\\DemoFilter: tags: - { name: coreshop.grid.filter, type: demo } Create PHP Class In this example we want to filter orders with available shipments in state &quot;ready&quot;. &lt;?php namespace AppBundle\\CoreShop\\OrderList\\Filter; use CoreShop\\Component\\Pimcore\\DataObject\\Grid\\GridFilterInterface; use Pimcore\\Db\\ZendCompatibility\\QueryBuilder; use Pimcore\\Model\\DataObject; class DemoFilter implements GridFilterInterface { public function getName(): string { return 'coreshop.order_filter.shipment_apply'; } public function filter(DataObject\\Listing $list, array $context): DataObject\\Listing { $list-&gt;onCreateQuery(function (QueryBuilder $select) use ($list) { $select-&gt;join( ['shipment' =&gt; 'object_query_4'], 'shipment.order__id = object_' . $list-&gt;getClassId() . '.o_id' ); }); $list-&gt;addConditionParam('orderState = ?', 'confirmed'); $list-&gt;addConditionParam('shipment.state = ?', 'ready'); return $list; } public function supports(string $listType): bool { return $listType === 'coreshop_order'; } }","tags":"","url":"Development\/Order\/OrderList\/Filter.html"},{"title":"Action","text":"CoreShop Order List Actions Actions allows you to process orders rapidly, right in the order grid view. Register Filter Service AppBundle\\CoreShop\\OrderList\\Action\\Demo: arguments: $stateMachineManager: '@coreshop.state_machine_manager' $shipmentRepository: '@coreshop.repository.order_shipment' tags: - { name: coreshop.grid.action, type: demo } Create PHP Class In this example we want to apply the shipment transition &quot;ship&quot; to selected orders. &lt;?php namespace AppBundle\\CoreShop\\OrderList\\Action; use CoreShop\\Component\\Order\\Repository\\OrderShipmentRepositoryInterface; use CoreShop\\Bundle\\WorkflowBundle\\Manager\\StateMachineManagerInterface; use CoreShop\\Component\\Pimcore\\DataObject\\Grid\\GridActionInterface; use Pimcore\\Model\\DataObject\\CoreShopOrder; class DemoAction implements GridActionInterface { protected $stateMachineManager; protected $shipmentRepository; public function __construct( StateMachineManagerInterface $stateMachineManager, OrderShipmentRepositoryInterface $shipmentRepository ) { $this-&gt;stateMachineManager = $stateMachineManager; $this-&gt;shipmentRepository = $shipmentRepository; } public function getName(): string { return 'coreshop.order.demo'; } public function apply(array $processIds): string { $message = ''; $transition = 'ship'; $shipmentIds = []; foreach ($processIds as $id) { $m = []; $order = CoreShopOrder::getById($id); $shipments = $this-&gt;shipmentRepository-&gt;getDocuments($order); if (count($shipments) === 0) { $m[] = sprintf('- no shipments for order %s found. skipping....', $order-&gt;getId()); } else { foreach ($shipments as $shipment) { if ($shipment-&gt;getState() === 'shipped') { $m[] = sprintf('- transition &quot;%s&quot; for shipment %s already applied. skipping...', $transition, $shipment-&gt;getId()); continue; } $workflow = $this-&gt;stateMachineManager-&gt;get($shipment, 'coreshop_shipment'); if (!$workflow-&gt;can($shipment, $transition)) { $m[] = sprintf('- transition &quot;%s&quot; for shipment %s not allowed.', $transition, $shipment-&gt;getId()); } else { try { $workflow-&gt;apply($shipment, $transition); $shipmentIds[] = $shipment-&gt;getId(); $m[] = sprintf('- transition &quot;%s&quot; for shipment id %s successfully applied.', $transition, $shipment-&gt;getId()); } catch (\\Exception $e) { $m[] = sprintf('- error while applying transition &quot;%s&quot; to shipment with id %s: %s.', $transition, $shipment-&gt;getId(), $e-&gt;getMessage()); } } } } $message .= sprintf('&lt;strong&gt;Order %s:&lt;\/strong&gt;&lt;br&gt;%s&lt;br&gt;', $id, join('&lt;br&gt;', $m)); } if (count($shipmentIds) &gt; 0) { $packingListUrl = '\/admin\/your-packing-list-generator-url?ids=' . join(',', $shipmentIds); $message .= sprintf('&lt;br&gt;&lt;a href=&quot;%s&quot; target=&quot;_blank&quot;&gt;%s&lt;\/a&gt;&lt;br&gt;', $packingListUrl, 'packing list'); } return $message; } public function supports(string $listType): bool { return $listType === 'coreshop_order'; } }","tags":"","url":"Development\/Order\/OrderList\/Action.html"},{"title":"TemplateHelper","text":"CoreShop Order Template\/Twig Helper Order State There is one Filter which returns you the current state for an order: {{ dump(order|coreshop_order_state) }}","tags":"","url":"Development\/Order\/TemplateHelper.html"},{"title":"AdditionalData","text":"Additional Data in Order Sometimes you need to implement additional information in your order (Besides the comment field, which is available by default in the shipping checkout step). Note: To add custom fields you need a custom checkout step. Create your custom brick and apply it to the classes: Cart (additionalData) Order (additionalData) Quote (additionalData) Add fields to your custom checkout step (createForm()): $form-&gt;add('af_secretField', TextType::class, [ 'required' =&gt; false, 'label' =&gt; 'coreshop.ui.your_secret_field' ]); $form-&gt;add('af_secondSecretField', TextType::class, [ 'required' =&gt; false, 'label' =&gt; 'coreshop.ui.your_second_secret_field' ]); Store data in cart (commitStep()) use Pimcore\\Model\\DataObject\\Objectbrick\\Data\\AdditionalField; if ($form-&gt;isSubmitted()) { if ($form-&gt;isValid()) { $formData = $form-&gt;getData(); if(!empty($formData['af_secretField'])) { $brick = new AdditionalField($cart); $brick-&gt;setSecretField($formData['af_secretField']); $brick-&gt;setSecondSecretField($formData['af_secondSecretField']); $cart-&gt;getAdditionalData()-&gt;setAdditionalField($brick); } $cart-&gt;save(); return true; } } That's it - your additional data is now available in backend. If you want to display those fields in the overview, you need to add some JS: core_shop_core: pimcore_admin: js: filter_condition_relational_multi_select: '\/bundles\/app\/additionalData.js' This file has to extend coreshop.order.sale.detail.abstractBlock and requires several methods: initBlock, updateSale, getPanel, getPriority and getPosition. pimcore.registerNS('coreshop.order.order.detail.blocks.yourBlockName'); coreshop.order.order.detail.blocks.yourBlockName = Class.create(coreshop.order.sale.detail.abstractBlock, { saleInfo: {}, hasItems: true, initBlock: function () { this.saleInfo = Ext.create('Ext.panel.Panel', { title: t('coreshop_order_additional_data'), margin: '0 20 20 0', border: true, flex: 8 }); }, updateSale: function () { var items = [], subItems = []; \/\/console.log(this.sale.additionalData); var items = [], subItems = []; Ext.Array.each(this.sale.additionalData, function (block, i) { var data = block.data; subItems.push({ xtype: 'label', style: 'font-weight:bold;display:block', text: 'Title for your custom field A' }, { xtype: 'label', style: 'display:block', html: data.secretField }); subItems.push({ xtype: 'label', style: 'font-weight:bold;display:block', text: 'Title for your custom field B' }, { xtype: 'label', style: 'display:block', html: data.secondSecretField }) }); if (subItems.length === 0) { this.hasItems = false; return; } items.push({ xtype: 'panel', bodyPadding: 10, margin: '0 0 10px 0', items: subItems }); \/\/ remove all before adding new ones \/\/ otherwise they will append during a refresh this.saleInfo.removeAll(); this.saleInfo.add(items); }, getPanel: function () { return this.hasItems ? this.saleInfo : null; }, getPriority: function () { return 10; }, getPosition: function () { return 'right'; } });","tags":"","url":"Development\/Order\/AdditionalData.html"},{"title":"Shipping","text":"CoreShop Shipping This guide should lead you through how CoreShop handles Shipping and Shipping Calculation. Carriers Shipping Rules","tags":"","url":"Development\/Shipping\/index.html"},{"title":"Carrier","text":"CoreShop Carrier This guide should lead you through how CoreShop handles Carriers. Create, Read, Update, Delete Carrier Discovery Price Calculation","tags":"","url":"Development\/Shipping\/Carrier\/index.html"},{"title":"CRUD","text":"CoreShop Carrier Create If you want to create a Carrier via API, you can do following: $newCarrier = $container-&gt;get('coreshop.factory.carrier')-&gt;createNew(); Now you have a new Carrier, if you want to persist it, you need to do following: $container-&gt;get('coreshop.manager.carrier')-&gt;persist($newCarrier); $container-&gt;get('coreshop.manager.carrier')-&gt;flush(); You now have a new persisted Carrier. Read If you want to query for Carriers, you can do following: $carrierRepository = $container-&gt;get('coreshop.repository.carrier'); $queryBuilder = $carrierRepository-&gt;createQueryBuilder('c'); \/\/ You can now create your query \/\/ And get the result $carriers = $queryBuilder-&gt;getQuery()-&gt;getResult(); Update If you want to update and existing Carrier, you need to do following: \/\/ Fetch Carrier $carrier = $carrierRepository-&gt;findById(1); $carrier-&gt;setName('Euro'); \/\/ And Persist it $container-&gt;get('coreshop.manager.carrier')-&gt;persist($carrier); $container-&gt;get('coreshop.manager.carrier')-&gt;flush(); Delete If you want to update and existing Carrier, you need to do following: \/\/ Fetch Carrier $carrier = $carrierRepository-&gt;findById(1); \/\/ And Persist it $container-&gt;get('coreshop.manager.carrier')-&gt;remove($carrier); $container-&gt;get('coreshop.manager.carrier')-&gt;flush();","tags":"","url":"Development\/Shipping\/Carrier\/CRUD.html"},{"title":"Carrier Discovery","text":"CoreShop Carrier Discovery CoreShop uses a Service to discover available Carriers for a given Shippable. These Service implements the Interface CoreShop\\Bundle\\ShippingBundle\\Discover\\ShippableCarriersDiscoveryInterface. The Interface is implemented by Service with ID coreshop.carrier.discovery","tags":"","url":"Development\/Shipping\/Carrier\/Carrier_Discovery.html"},{"title":"Price Calculation","text":"CoreShop Carrier Price Calculation CoreShop Shipping\/Carrier Calculation uses multiple Calculation methods to calculate the price for a given Carrier on a given Cart. A Calculator needs to implement the Interface CoreShop\\Component\\Shipping\\Calculator\\CarrierPriceCalculatorInterface and registered to the container using the tag coreshop.shipping.price_calculator, a type attribute and a priority Default Implementation The Default Implementation calculates the Price based on Shipping Rules.","tags":"","url":"Development\/Shipping\/Carrier\/Price_Calculation.html"},{"title":"Shipping Rules","text":"CoreShop Shipping Rules Default Conditions and Actions CoreShop comes with a set of default action and condition implementations: Default Conditions Currencies Customer Groups Customers Stores Zones Amount Categories Countries Dimension Post Codes Products Shipping Rule Weight Nested Default Actions Addition Amount Addition Percent Discount Amount Discount Percent Price Shipping Rule Extending Conditions and Actions Click here to see how you can add custom Actions Click here to see how you can add custom Conditions","tags":"","url":"Development\/Shipping\/Shipping_Rules\/index.html"},{"title":"Index and Filters","text":"CoreShop Index and Filter This guide should lead you through how CoreShop handles Indices and Filters. Indices Filters","tags":"","url":"Development\/Index_and_Filters\/index.html"},{"title":"Index","text":"CoreShop Index To create a rich layered navigation (faceted navigation), you need to create an index of your Products. Create a new Index CoreShop currently supports two type of indexes: Mysql ~~Elasticsearch~~ Add Fields To add a new field, simply drag'n'drop the field from the left tree to the right tree. Field Properties Every field has some properties that needs to be configured Field Description Key Pimcore Field Name Name Name in the Index Getter Class Getter Class is important for field-types like &quot;Localized Fields&quot;, &quot;Classification Store&quot;, &quot;Object Brick&quot; and &quot;Field Collection&quot;. CoreShop needs it to get the right value for the index Interpreter Using Interpreters helps you to transform values before they get stored in the index. For example: Resolving dependencies, create a similarity Index Type Type of the field in the index, depends on which Index-Type you are using. MySql or Elasticsearch Getter Config Configuration depends on Getter, for example: Language for Localized Fields Re-Index If you make changes to the index, you need to re-index all of your products. To do that, there is a CLI command. $ php bin\/console coreshop:index If you don't want to re-index all of your indices, you can pass the corresponding IDs or names of the indices separated with a space as arguments to the CLI command. The following example will only re-index indices with IDs 1 and 2 and name &quot;Products&quot;. If none of those indices exist, nothing will be re-indexed. $ php bin\/console coreshop:index 1 2 Products","tags":"","url":"Development\/Index_and_Filters\/Index\/index.html"},{"title":"Interpreter","text":"CoreShop Index Interpreter To prepare your index and transform data, you use one of the existing Interpreter or create one yourself. CoreShop currently has following Interpreters: Object: converts an object or and object array to relations. It saves the values to the relations inex ObjectId: converts an object to its ID ObjectIdSum: calculates the sum of all IDs. (Could be used for similar products) ObjectProperty: calls a getter method of the value Soundex: calls PHP soundex function (Could be used for similar products) Create a Custom Interpreter 1 We need to create 2 new files: FormType for processing the Input Data And a InterpreterInterface, which interprets the data namespace AppBundle\\Index\\Form\\Type; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\IntegerType; use Symfony\\Component\\Form\\FormBuilderInterface; use Symfony\\Component\\Validator\\Constraints\\NotBlank; use Symfony\\Component\\Validator\\Constraints\\Type; final class MyInterpreterType extends AbstractType { \/** * {@inheritdoc} *\/ public function buildForm(FormBuilderInterface $builder, array $options) { $builder -&gt;add('myInterpreterData', IntegerType::class, [ 'constraints' =&gt; [ new NotBlank(['groups' =&gt; ['coreshop']]), new Type(['type' =&gt; 'numeric', 'groups' =&gt; ['coreshop']]), ], ]) ; } } namespace AppBundle\\CoreShop\\Index\\Interpreter; use CoreShop\\Component\\Index\\Interpreter\\InterpreterInterface; class MyInterpreter implements InterpreterInterface { public function interpret($value, IndexableInterface $indexable, IndexColumnInterface $config, array $interpreterConfig = []) { \/\/Do some interpretation here return $value; } } 2:Register MyInterpreter as service with tag coreshop.index.interpreter, type and form app.index.interpreter.my_interpreter: class: AppBundle\\CoreShop\\Index\\Interpreter\\MyInterpreter tags: - { name: coreshop.index.interpreter, type: my_interpreter, form-type: AppBundle\\Index\\Form\\Type\\MyInterpreterType}","tags":"","url":"Development\/Index_and_Filters\/Index\/Interpreter.html"},{"title":"Extension","text":"CoreShop Index Extension In order to make the index more flexible, it is possible for you to write extensions. Extensions allow you to do following things: - Add more &quot;default&quot; columns and corresponding data - Pre Filter an mysql index To create a new extension, you need to implement either the interface CoreShop\\Component\\Index\\Extension\\IndexColumnsExtensionInterface for column extensions or the interface CoreShop\\Bundle\\IndexBundle\\Extension\\MysqlIndexQueryExtensionInterface for mysql query extensions. You then need to register your service using the tag coreshop.index.extension","tags":"","url":"Development\/Index_and_Filters\/Index\/Extension.html"},{"title":"Filter","text":"CoreShop Filter After creating the index, you can configure the Filters. Create a new Filter You can create different Filters for different Categories. A filter exists of different settings, pre-conditions, filters and similar products. You can even create Custom Filters Filter Settings Field Description Name Name of the Filter-Set Index Which Index should be used Order Order of the products Order Key Order key (index-field) to sort from Results per Page How many products should be displayed per page, you can use Shop Settings, or override it Pre-Conditions You can define pre-filters for the index. Conditions Here you can define different kind of filters. These filters will be displayed on the front-page for customers to find products. CoreShop currently supports 4 types of filters: Select Multiselect Range Boolean Select Condition A select condition is basically just a simple dropdown field where customer can select one field. Multiselect Condition A multi-select condition is basically a list of fields where customer can select multiple entries. Range Condition A Range Condition is a slider of two ranges. The ranges are calculated automatically using MIN and MAX values. Boolean Condition Boolean is a Condition where the customer can check different values.","tags":"","url":"Development\/Index_and_Filters\/Filter\/index.html"},{"title":"Custom Filter","text":"CoreShop Filter - Create Custom Filter 1. We need to create 2 new files: - FormType for processing the Input Data - And a FilterConditionProcessorInterface, which checks if a cart fulfills the condition. namespace AppBundle\\Filter\\Form\\Type\\Condition; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\IntegerType; use Symfony\\Component\\Form\\FormBuilderInterface; use Symfony\\Component\\Validator\\Constraints\\NotBlank; use Symfony\\Component\\Validator\\Constraints\\Type; final class MyFilterCondition extends AbstractType { \/** * {@inheritdoc} *\/ public function buildForm(FormBuilderInterface $builder, array $options) { $builder -&gt;add('myData', IntegerType::class, [ 'constraints' =&gt; [ new NotBlank(['groups' =&gt; ['coreshop']]), new Type(['type' =&gt; 'numeric', 'groups' =&gt; ['coreshop']]), ], ]) ; } } namespace AppBundle\\Filter; use CoreShop\\Component\\Address\\Model\\AddressInterface; use CoreShop\\Component\\Core\\Model\\CarrierInterface; class MyFilterCondition extends FilterConditionProcessorInterface { public function prepareValuesForRendering(FilterConditionInterface $condition, FilterInterface $filter, ListingInterface $list, $currentFilter) { \/\/Prepare values for rendering HTML } public function addCondition(FilterConditionInterface $condition, FilterInterface $filter, ListingInterface $list, $currentFilter, ParameterBag $parameterBag, $isPrecondition = false) { \/\/Add Condition to Listing return $currentFilter; } } 2. Register MyFilterCondition as service with tag coreshop.filter.condition_type, type and form app.coreshop.shipping_rule.condition.my_rule: class: AppBundle\\Shipping\\Rule\\Condition\\MyRuleConditionChecker tags: - { name: coreshop.shipping_rule.condition, type: my_rule, form-type: AppBundle\\Shipping\\Form\\Type\\Condition\\MyRuleConfigurationType } app.filter.condition_type.my_filter_condition: class: AppBundle\\Filter\\MyFilterCondition tags: - { name: coreshop.filter.condition_type, type: app-my-filter, form-type: AppBundle\\Filter\\Form\\Type\\Condition\\MyFilterCondition}","tags":"","url":"Development\/Index_and_Filters\/Filter\/Custom_Filter.html"},{"title":"Notification Rules","text":"CoreShop Notification Rules Notification Rules are responsible for all types of notification triggered by CoreShop. It handles notification for following types: order quote invoice shipment user payment Overview Let's checkout each notification type: Order Allowed Conditions Name Description Invoice State Dispatch if given Invoice State is active Invoice Transition Dispatch if given Invoice Transition has been applied Payment State Dispatch if given Payment State is active Payment Transition Dispatch if given Payment Transition has been applied Shipping State Dispatch if given Shipping State is active Shipping Transition Dispatch if given Shipping Transition has been applied Order State Dispatch if given Order State is active Order Transition Dispatch if given Order Transition has been applied Carriers Dispatch if given Carrier has been selected in Order Comment Dispatch if a Comment Action has been applied. Available Types: create comment Allowed Actions Name Description Order Email Email with Order Object Email Default Email without Order Object Available Placeholders keys for email templates Key Value object Object of type OrderInterface fromState State identifier from which it is transitioning away from toState State identifier from which it is transitioning to transition Used transition _locale Used locale recipient Customer E-Mail Address firstname Customer Firstname lastname Customer Lastname orderNumber Order Number Available Placeholders keys for email templates for comment Key Value object Object of type OrderInterface _locale Used locale recipient Customer E-Mail Address firstname Customer Firstname lastname Customer Lastname orderNumber Order Number type Type of comment submitAsEmail should comment be sent as mail comment contents of the comment Shipment Allowed Conditions Name Description Shipping State Dispatch if given Shipping State is active Shipping Transition Dispatch if given Shipping Transition has been applied Allowed Actions Name Description Order Email Email with Order Object Email Default Email without Order Object Available Placeholders keys for email templates Key Value object Object of type OrderShipmentInterface order Object of type OrderInterface fromState State identifier from which it is transitioning away from toState State identifier from which it is transitioning to transition Used transition Invoice Allowed Conditions Name Description Invoice State Dispatch if given Invoice State is active Invoice Transition Dispatch if given Invoice Transition has been applied Allowed Actions Name Description Order Email Email with Order Object Email Default Email without Order Object Available Placeholders keys for email templates Key Value object Object of type OrderInvoiceInterface order Object of type OrderInterface fromState State identifier from which it is transitioning away from toState State identifier from which it is transitioning to transition Used transition Payment Allowed Conditions Name Description Payment State Dispatch if given Payment State is active Payment Transition Dispatch if given Payment Transition has been applied Allowed Actions Name Description Order Email Email with Order Object Email Default Email without Order Object Available Placeholders keys for email templates Key Value object Object of type PaymentInterface order Object of type OrderInterface paymentState State of the Payment User Allowed Conditions Name Description User Type Dispatch if given Type has been applied. Allowed Types: new account, password reset Allowed Actions Name Description Email Default Email without Order Object Available Placeholders keys for email templates Key Value object Object of type CustomerInterface recipient Customer E-Mail Address gender Customer Gender firstname Customer Firstname lastname Customer Lastname email Customer E-Mail type type of customer notification Additional Placeholders keys for Password Reset Key Value resetLink Link where customer can reset his Password Additional Placeholders keys for Request Newsletter Key Value confirmLink Link where customer can confirm his Newsletter subscription token Confirmation Token Quote Allowed Conditions Name Description Carriers Dispatch if given Carrier has been selected in Order Allowed Actions Name Description Email Default Email without Order Object Available Placeholders keys for email templates Key Value object Object of type QuoteInterface Custom Implementation It's also easy to implement custom notification rules. Read more about this here Extend CoreShop Notification Rules Custom Actions Custom Conditions Custom Types Triggering Notifications","tags":"","url":"Development\/Notification_Rules\/index.html"},{"title":"Custom Actions","text":"CoreShop Notification Rule Custom Actions Click here to see how you can add custom Actions","tags":"","url":"Development\/Notification_Rules\/Custom_Actions.html"},{"title":"Custom Conditions","text":"CoreShop Notification Rule Custom Conditions Click here to see how you can add custom Conditions","tags":"","url":"Development\/Notification_Rules\/Custom_Conditions.html"},{"title":"Custom Types","text":"CoreShop Notification Rule Custom Type Notification Types are registered dynamically by using tag-attributes on conditions and actions. If you want to have your own type, you can do so by adding a new condition or action and specify your own type: services: app.coreshop.notification_rule.condition.order.custom_notification_condition: class: AppBundle\\CoreShop\\Notification\\CustomNotificationCondition tags: - { name: coreshop.notification_rule.condition, type: custom_condition, notification-type: custom, form-type: AppBundle\\Form\\Type\\CoreShop\\CustomConditionType }","tags":"","url":"Development\/Notification_Rules\/Custom_Types.html"},{"title":"Triggering","text":"CoreShop Notification Trigger Notifications Triggering Notification events is quite easy, you can use the CoreShop\\Component\\Notification\\Processor\\RulesProcessorInterface implemented by service @coreshop.notification_rule.processor You also need to add different kinds of parameters based on your Notification Type. In our case, we trigger an Order event. $this-&gt;rulesProcessor-&gt;applyRules('order', $event-&gt;getProposal(), [ 'fromState' =&gt; $event-&gt;getMarking()-&gt;getPlaces(), 'toState' =&gt; $event-&gt;getTransition()-&gt;getTos(), '_locale' =&gt; $order-&gt;getLocaleCode(), 'recipient' =&gt; $customer-&gt;getEmail(), 'firstname' =&gt; $customer-&gt;getFirstname(), 'lastname' =&gt; $customer-&gt;getLastname(), 'orderNumber' =&gt; $order-&gt;getOrderNumber(), 'transition' =&gt; $event-&gt;getTransition()-&gt;getName() ]); The rest is now handled by CoreShop Notifications.","tags":"","url":"Development\/Notification_Rules\/Triggering.html"},{"title":"Payment","text":"CoreShop Payment CoreShop contains a very flexible payments management system with support for many gateways (payment providers). We are using a payment abstraction library - Payum, which handles all sorts of capturing, refunding and recurring payments logic. On CoreShop side, we integrate it into our checkout and manage all the payment data. Available Payment Gateways for CoreShop Name State Link Support Offsite Supports Server-Notification Supports Refund Heidelpay stable Github PayPal, Klarna Sofort, Credit Card No Yes No SaferPay stable Github Supported Payment Methods Yes Yes Partially PostFinance stable Github PostFinance Card, PostFinance E-Finance, Visa, MasterCard, Diners Club, American Express, JCB, PayPal, TWINT Yes Yes No PowerPay dev Github invoice, automatic credit check No No (not required) No CuraBill dev Github invoice, instalments via iframe No No (not required) No Payment Every payment in CoreShop, successful or failed, is represented by the payment model, which contains basic information and a reference to appropriate order. Create a Payment programmatically As usually, use a factory to create a new PaymentMethod and give it a unique code. $payment = $this-&gt;container-&gt;get('coreshop.factory.payment')-&gt;createNew(); $payment-&gt;setOrder($order); $payment-&gt;setCurrencyCode('EUR'); $this-&gt;container-&gt;get('coreshop.repository.payment')-&gt;add($payment); More Payment Provider Ominpay Bridge Payum Providers","tags":"","url":"Development\/Payment\/index.html"},{"title":"Payment Provider","text":"CoreShop Payment Providers A Payment Provider represents a way that your customer pays during the checkout process. It holds a reference to a specific gateway with custom configuration. A gateway is configured for each payment method separately using the payment method form. Payment Gateway configuration Payment Gateways that already have a CoreShop bridge First you need to create the configuration form type for your gateway. Have a look at the configuration form types of Paypal and Sofort. Then you should register its configuration form type with coreshop.gateway_configuration_type tag. After that it will be available in the admin panel in the gateway choice dropdown. If you are not sure how your configuration form type should look like, head to Payum documentation. Other Payment Gateways Learn more about integrating payment gateways in the Payum docs. You\u2019ll probably need also this kind of configuration in your app\/config\/config.yml for the gateway\u2019s factory: payum: gateways: yourgateway: factory: yourgateway As an example, we add Sofort as a payment gateway factory. To add a new gateway configuration you need to add 2 files: A new FormType for configuration values A new Javascript File for ExtJs Form 1: Form Type for Configuration Values: namespace AppBundle\\CoreShop\\Form\\Type; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType; use Symfony\\Component\\Form\\FormBuilderInterface; use Symfony\\Component\\Form\\FormEvent; use Symfony\\Component\\Form\\FormEvents; use Symfony\\Component\\Validator\\Constraints\\NotBlank; final class SofortGatewayConfigurationType extends AbstractType { \/** * {@inheritdoc} *\/ public function buildForm(FormBuilderInterface $builder, array $options) { $builder -&gt;add('config_key', TextType::class, [ 'constraints' =&gt; [ new NotBlank([ 'groups' =&gt; 'coreshop', ]), ], ]) -&gt;addEventListener(FormEvents::PRE_SET_DATA, function (FormEvent $event) { $data = $event-&gt;getData(); $data['payum.http_client'] = '@coreshop.payum.http_client'; }) ; } } Now we register the FormType into the container services: app.coreshop.form.type.gateway_configuration.sofort: class: AppBundle\\Form\\Type\\SofortGatewayConfigurationType tags: - { name: coreshop.gateway_configuration_type, type: sofort } - { name: form.type } 2: Create the corresponding ExtJs Form: You need to use the type attribute as identifier here pimcore.registerNS('coreshop.provider.gateways.sofort'); coreshop.provider.gateways.sofort = Class.create(coreshop.provider.gateways.abstract, { getLayout: function (config) { return [ { xtype: 'textfield', fieldLabel: t('config_key'), name: 'gatewayConfig.config.config_key', length: 255, value: config.config_key ? config.config_key : &quot;&quot; } ]; } }); Next we need to register our new Gateway JS file to be loaded: core_shop_payment: pimcore_admin: js: sofort_gateway: '\/bundles\/app\/pimcore\/js\/sofort.js' Thats it, now after reloading Pimcore, you'll see a new Factory.","tags":"","url":"Development\/Payment\/Payment_Provider.html"},{"title":"Omnipay Bridge","text":"CoreShop Payum Ominpay Bridge Here is a list of all available Omnipay Payment Providers. As of now, Omnipay is not compatible with Symfony 3. They are already working on it, but will need some time to be finished. But: You can use the dev-master Version Omnipay to add the Bridge To add the Omnipay Bridge, do following: $ composer require payum\/omnipay-v3-bridge:dev-master This will install the Bridge for you. Now you still need to create your Gateway Configuration as described here. Example of Omnipay Gateway Configuration As example we add omnipay-worldpay: Worldpay is currently in PR and I don't know when it is getting merged 1: add FormType for Worldpay Configuration: &lt;?php namespace AppBundle\\Form\\Type; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\PasswordType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType; use Symfony\\Component\\Form\\FormBuilderInterface; use Symfony\\Component\\Form\\FormEvent; use Symfony\\Component\\Form\\FormEvents; use Symfony\\Component\\Validator\\Constraints\\NotBlank; final class WorldpayType extends AbstractType { \/** * {@inheritdoc} *\/ public function buildForm(FormBuilderInterface $builder, array $options) { $builder -&gt;add('serviceKey', TextType::class, [ 'constraints' =&gt; [ new NotBlank([ 'groups' =&gt; 'coreshop', ]), ], ]) -&gt;add('clientKey', PasswordType::class, [ 'constraints' =&gt; [ new NotBlank([ 'groups' =&gt; 'coreshop', ]), ], ]) -&gt;add('merchantId', TextType::class, [ 'constraints' =&gt; [ new NotBlank([ 'groups' =&gt; 'coreshop', ]), ], ]) -&gt;add('factory', TextType::class, [ 'data' =&gt; 'omnipay', 'empty_data' =&gt; 'omnipay' ]) -&gt;add('type', TextType::class, [ 'data' =&gt; 'WorldPay\\\\Json', 'empty_data' =&gt; 'WorldPay\\\\Json' ]) -&gt;addEventListener(FormEvents::PRE_SET_DATA, function (FormEvent $event) { $data = $event-&gt;getData(); $data['payum.http_client'] = '@coreshop.payum.http_client'; }) ; } } Register into the container: services: app.form.type.gateway_configuration.worldpay: class: AppBundle\\Form\\Type\\WorldpayType tags: - { name: coreshop.gateway_configuration_type, type: omnipay_worldpay } - { name: form.type } Its important that it starts with omnipay_ here 2: Add ExtJs Form: pimcore.registerNS('coreshop.provider.gateways.omnipay_worldpay'); coreshop.provider.gateways.omnipay_worldpay = Class.create(coreshop.provider.gateways.abstract, { getLayout: function (config) { return [ { xtype: 'textfield', fieldLabel: t('coreshop_worldpay_service_key'), name: 'gatewayConfig.config.serviceKey', length: 255, value: config.serviceKey ? config.serviceKey : &quot;&quot; }, { xtype: 'textfield', fieldLabel: t('coreshop_worldpay_client_key'), name: 'gatewayConfig.config.clientKey', length: 255, value: config.clientKey }, { xtype: 'textfield', fieldLabel: t('coreshop_worldpay_merchant_id'), name: 'gatewayConfig.config.merchantId', length: 255, value: config.merchantId } ]; } }); Register JS File for CoreShop to be loaded: core_shop_payment: pimcore_admin: js: worldpay: \/bundles\/app\/pimcore\/static\/js\/payment\/provider\/worldpay.js Thats it, now you can create a new Payment Provider in the Backend and use Omnipay WorldPay as Payment Provider.","tags":"","url":"Development\/Payment\/Omnipay_Bridge.html"},{"title":"Payum Providers","text":"CoreShop Payum Providers Here is a list of all available Payum Payment Providers.","tags":"","url":"Development\/Payment\/Payum_Providers.html"},{"title":"Stores","text":"CoreShop Stores CoreShop Stores help you create a multi-store based eCommerce System with different Themes across these Stores. Create, Read, Update, Delete Store Context Theming","tags":"","url":"Development\/Stores\/index.html"},{"title":"CRUD","text":"CoreShop Stores Create If you want to create a Store via API, you can do following: $newStore = $container-&gt;get('coreshop.factory.store')-&gt;createNew(); Now you have a new Store, if you want to persist it, you need to do following: $container-&gt;get('coreshop.manager.store')-&gt;persist($newStore); $container-&gt;get('coreshop.manager.store')-&gt;flush(); You now have a new persisted Store. Read If you want to query for Stores, you can do following: $storeRepository = $container-&gt;get('coreshop.repository.store'); $queryBuilder = $storeRepository-&gt;createQueryBuilder('c'); \/\/ You can now create your query \/\/ And get the result $stores = $queryBuilder-&gt;getQuery()-&gt;getResult(); Update If you want to update and existing Store, you need to do following: \/\/ Fetch Store $store = $storeRepository-&gt;findById(1); $store-&gt;setName('Euro'); \/\/ And Persist it $container-&gt;get('coreshop.manager.store')-&gt;persist($store); $container-&gt;get('coreshop.manager.store')-&gt;flush(); Delete If you want to update and existing Store, you need to do following: \/\/ Fetch Store $store = $storeRepository-&gt;findById(1); \/\/ And Persist it $container-&gt;get('coreshop.manager.store')-&gt;remove($store); $container-&gt;get('coreshop.manager.store')-&gt;flush();","tags":"","url":"Development\/Stores\/CRUD.html"},{"title":"Context","text":"CoreShop Store Context For CoreShop to determine the current store the visitor or customer comes from it uses a concept called context and context resolver. Context Name Priority Tag Description FixedStoreContext 2 coreshop.context.store Used for testing purposes StoreContext 1 coreshop.context.store Load a store from given request resolver Resolver Name Priority Tag Description SiteBasedRequestResolver 100 coreshop.context.store.request_based.resolver Determines a store by a given pimcore frontend site PimcoreAdminSiteBasedRequestResolver 200 coreshop.context.store.request_based.resolver Determines a store by a given document in backend These resolver take care about finding the correct store for the current request. Create a Custom Resolver A Store Context needs to implement the interface CoreShop\\Component\\Store\\Context\\StoreContextInterface. This interface consists of one method called getStore which returns a CoreShop\\Component\\Store\\Model\\StoreInterface or throws an CoreShop\\Component\\Store\\Context\\StoreNotFoundException. To register your context, you need to use the tag coreshop.context.store with an optional priority attribute. Create a Request based Resolver CoreShop already implements Request based store context resolver. So if your context depends on the current request, you can create a custom RequestBased resolver. To do that, implement the interface CoreShop\\Component\\Store\\Context\\RequestBased\\RequestResolverInterface with the method findStore. This method either returns a store or null. To register this resolver, use the tag: coreshop.context.store.request_based.resolver with an optional priority attribute. Example We want to a StoreContext to be based on the Pimcore Document. So if we are on site \/de, we want to resolve to Store DE, if we are on page \/en we want to resolve to Store Store EN: 1: First of all we need to create our RequestBased Store Context: &lt;?php namespace AppBundle\\CoreShop\\Store\\Context; use CoreShop\\Component\\Store\\Context\\RequestBased\\RequestResolverInterface; use CoreShop\\Component\\Store\\Repository\\StoreRepositoryInterface; use Pimcore\\Http\\Request\\Resolver\\DocumentResolver; use Symfony\\Component\\HttpFoundation\\Request; final class DocumentBasedRequestRequestResolver implements RequestResolverInterface { private StoreRepositoryInterface $storeRepository; public function __construct(StoreRepositoryInterface $storeRepository) { $this-&gt;storeRepository = $storeRepository; } public function findStore(Request $request): ?StoreInterface { if (substr($request-&gt;getPathInfo(), 0, 3) === '\/en') { return $this-&gt;storeRepository-&gt;find(1); } if (substr($request-&gt;getPathInfo(), 0, 3) === '\/de') { return $this-&gt;storeRepository-&gt;find(2); } return null; } } Now we need to configure the service in src\/AppBundle\/Resources\/config\/services.yml services: app.coreshop.store.context.request.document_based: class: AppBundle\\CoreShop\\Store\\Context\\DocumentBasedRequestRequestResolver arguments: - '@coreshop.repository.store' tags: - { name: coreshop.context.store.request_based.resolver, priority: 300 } CoreShop now tries to resolve the current Store based on the Pimcore Site we are on.","tags":"","url":"Development\/Stores\/Context.html"},{"title":"Theme","text":"CoreShop Stores Theming CoreShop Stores are designed to allow different Themes. Therefore you can have a true Multi-Store Environment with different Themes. CoreShop uses Sylius Theme Bundle for templates, read more at their docs on how it works: https:\/\/docs.sylius.com\/en\/1.9\/book\/themes\/themes.html","tags":"","url":"Development\/Stores\/Theme.html"},{"title":"Customers","text":"CoreShop Customer This guide should lead you through how CoreShop handles Customer Information. Create, Read, Update, Delete Customer Context Registration Service Registration Types Company Extension","tags":"","url":"Development\/Customers\/index.html"},{"title":"CRUD","text":"CoreShop Custom CoreShop uses Pimcore Data Objects to persist Customer Information. But, it adds a little wrapper around it to be mire dynamic and configurable. It uses a Factory and Repository Pattern to do that. Create If you want to create a new Custom, we need to get our Factory Service for that: $customerFactory = $container-&gt;get('coreshop.factory.customer'); $customer = $customerFactory-&gt;createNew(); No we have our customer and we can set all needed values. If you now want to save it, just call the save function $customer-&gt;save(); Read To get customers, you need to use the Repository Service CoreShop provides you. $repository = $container-&gt;get('coreshop.repository.customer'); \/\/ Query by ID $customerWithIdOne = $repository-&gt;findById(1); \/\/ Get a Listing how you know it from Pimcore $list = $repository-&gt;getList(); $list-&gt;setCondition(&quot;active = 1&quot;); $customers = $list-&gt;getObjects(); Update Update works the same as you are used to in Pimcore $repository = $container-&gt;get('coreshop.repository.customer'); \/\/ Query by ID $customerWithIdOne = $repository-&gt;findById(1); \/\/ Change values $customerWithIdOne-&gt;setName('test'); $customerWithIdOne-&gt;save(); Delete Delete works the same as you are used to in Pimcore $repository = $container-&gt;get('coreshop.repository.customer'); \/\/ Query by ID $customerWithIdOne = $repository-&gt;findById(1); $customerWithIdOne-&gt;delete();","tags":"","url":"Development\/Customers\/CRUD.html"},{"title":"Context","text":"CoreShop Customer Context CoreShop Customer Security uses Symfony Firewall to handle authentication. CoreShop implemented a Context based Wrapper around that to be more flexible. Currently CoreShop implements these Contexts for Customer determination: Security Token Based Create a Custom Resolver A Store Context needs to implement the interface CoreShop\\Component\\Customer\\Context\\CustomerContextInterface. This interface consists of one function called &quot;getCustomer&quot; which returns a CoreShop\\Component\\Customer\\Model\\CustomerInterface or throws an CoreShop\\Component\\Customer\\Context\\CustomerNotFoundException To register your context, you need to use the tag: coreshop.context.customer with an optional priority attribute. The use case of changing this is quite rare. But if you need to, you can create a Custom Resolver if you wish.","tags":"","url":"Development\/Customers\/Context.html"},{"title":"Customer Manager","text":"CoreShop Customer Manager CoreShop already implements a Customer Manager which handles creating a Customer with Addresses. The Customer Manager implements the Interface CoreShop\\Bundle\\CoreBundle\\Customer\\CustomerManagerInterface and CoreShop implements it using the service coreshop.customer.manager. Usage To use the Service, you need to pass a Customer. In our example, we gonna do that from a Controller with a FormType. $customer = $this-&gt;getCustomer(); if ($customer instanceof CustomerInterface &amp;&amp; null === $customer-&gt;getUser()) { return $this-&gt;redirectToRoute('coreshop_customer_profile'); } $form = $this-&gt;get('form.factory')-&gt;createNamed('customer', CustomerRegistrationType::class, $this-&gt;get('coreshop.factory.customer')-&gt;createNew()); $redirect = $this-&gt;getParameterFromRequest($request, '_redirect', $this-&gt;generateUrl('coreshop_customer_profile')); if (in_array($request-&gt;getMethod(), ['POST', 'PUT', 'PATCH'], true)) { $form = $form-&gt;handleRequest($request); if ($form-&gt;isValid()) { $customer = $form-&gt;getData(); $customer-&gt;setLocaleCode($this-&gt;get('coreshop.context.locale')-&gt;getLocaleCode()); $this-&gt;get('coreshop.customer.manager')-&gt;persistCustomer($customer); return $this-&gt;redirect($redirect); } } return $this-&gt;render($this-&gt;templateConfigurator-&gt;findTemplate('Register\/register.html'), [ 'form' =&gt; $form-&gt;createView(), ]);","tags":"","url":"Development\/Customers\/Customer_Manager.html"},{"title":"Registration Types","text":"CoreShop Customer Registration Types By default, a customer needs to provide a unique and valid email address to pass a registration. Register By Email This is the default setting! To switch to registration by a unique and valid email address, you need set the identifier: core_shop_customer: login_identifier: 'email' Register By Username First, you need to make sure your customer object provides a username field. By default, coreshop does not install this field to prevent unnecessary confusion. To implement the username field, just open your class editor and add a text field called username and you're good to go! To switch to registration by a unique username, you need change the identifier: core_shop_customer: login_identifier: 'username' Security Form (Frontend) CoreShop comes with a preinstalled constraint which will tell your customer, if an email address or username - depending on your settings - is valid or not. Backend \/ API Plus, if you're going to update a customer by API or Backend, coreshop also checks if your customer entity has unique data. Note: Both checks only apply to non-guest entities!","tags":"","url":"Development\/Customers\/Registration_Types.html"},{"title":"Company Extension","text":"CoreShop Customer Company Extension The Company Entity allows you to append customers to a given company. After a customer has been connected to a company by using the 1to1 relation company, it's possible to share addresses between company and the self-assigned addresses. Access Types Note! This is only available if a customer already is connected to a valid company! Own Only If set, the customer can create, edit and delete own addresses and choose them in checkout as well. This is the default behaviour. Company Only If set, the customer can create, edit und delete company addresses and choose them in checkout as well. He's not able to add addresses to himself. Own And Company If set, the customer can create, edit and delete company and private addresses and choose them in checkout as well. Plus, the own_and_company mode allows the customer to define and modify the allocation of the address. To do so, coreshop renders an additional choice type to the address creation\/modification form. Note: If a customer switches the allocation after it has been created, the address also physically gets moved to its desired location. In this example, the customer changes the allocation from own to company: Before: - company A - addresses - customer A - addresses - address A After: - company A - addresses - address A - customer A - addresses Read more about this feature here.","tags":"","url":"Development\/Customers\/Company_Extension.html"},{"title":"Ecommerce Tracking","text":"CoreShop eCommerce Tracking CoreShop currently implements Tracking for Analytics and Google Tag Manager. Tracking is automatically available (but not enabled), as soon as you enable Tag Manager or Analytics in Pimcore. Per default configuration, all the ecommerce trackers are disabled. You need to enable them manually. Available Trackers google-analytics-enhanced-ecommerce google-analytics-universal-ecommerce google-gtag-enhanced-ecommerce google-gtm-classic-ecommerce google-gtm-enhanced-ecommerce matomo (piwik) Enabling Trackers core_shop_tracking: trackers: google-analytics-enhanced-ecommerce: enabled: false google-analytics-universal-ecommerce: enabled: false google-gtag-enhanced-ecommerce: enabled: false google-gtm-classic-ecommerce: enabled: false google-gtm-enhanced-ecommerce: enabled: false matomo: enabled: true External Google Enhanced E-Commerce Google Enhanced E-Commerce with gtag.js Google Tag Manager Enhanced E-Commerce Google Tag Manager Classic E-Commerce Matomo (Piwik) E-Commerce Actions Product Impression $this-&gt;get('coreshop.tracking.manager')-&gt;trackProductImpression($product); Product View $this-&gt;get('coreshop.tracking.manager')-&gt;trackProduct($product); Product Action Add from Cart $this-&gt;get('coreshop.tracking.manager')-&gt;trackCartAdd($cart, $product); Product Action Remove from Cart $this-&gt;get('coreshop.tracking.manager')-&gt;trackCartRemove($cart, $product); Checkout Step $this-&gt;get('coreshop.tracking.manager')-&gt;trackCheckoutStep($cart, $stepIdentifier, $isFirstStep, $checkoutOption) Checkout Complete $this-&gt;get('coreshop.tracking.manager')-&gt;trackCheckoutComplete($order) Add a custom Tracker To add a custom tracker you need to implement the interface CoreShop\\Component\\Tracking\\Tracker\\TrackerInterface app.tracking.tracker.my_tracker: class: AppBundle\\Tracker\\CustomTracker parent: coreshop.tracking.tracker.ecommerce_tracker tags: - { name: coreshop.tracking.tracker, type: app-custom-tracker } Google Tag Manager If you have enabled the gtm in backend, CoreShop sends some data to a dataLayer object which submits the object to gtm. GTM Classic eCommerce If you enable the classic mode only the order gets submitted if user has successfully reached the &quot;thank-you&quot; page. GTM Enhanced eCommerce There are six Impressions\/Events for Google Tag Manager Enhanced eCommerce: Product Impression Tag Config Example: Tag type : Universal Analytics Track type : Pageview Enable Enhanced Ecommerce Features: true Use Data Layer: true Trigger: event equals gtm.dom Product Detail View Tag Config Example: Tag type : Universal Analytics Track type : Pageview Enable Enhanced Ecommerce Features: true Use Data Layer: true Trigger: event equals gtm.dom Checkout Step: Event-Name: csCheckout Tag Config Example: Tag type : Universal Analytics Track type : Event Event Category: Ecommerce Event Action: Checkout Enable Enhanced Ecommerce Features: true Use Data Layer: true Trigger: event equals csCheckout Checkout Complete (Purchase): Tag Config Example: Tag type : Universal Analytics Track type : Pageview Enable Enhanced Ecommerce Features: true Use Data Layer: true Trigger: event equals gtm.dom Remove Item from Cart Event-Name: csRemoveFromCart Tag Config Example: Tag type : Universal Analytics Track type : Event Event Category: Ecommerce Event Action: Remove from Cart Enable Enhanced Ecommerce Features: true Use Data Layer: true Trigger: event equals csRemoveFromCart Add Item to Cart Event-Name: csAddToCart Tag Config Example: Tag type : Universal Analytics Track type : Event Event Category: Ecommerce Event Action: Add to Cart Enable Enhanced Ecommerce Features: true Use Data Layer: true Trigger: event equals csAddToCart","tags":"","url":"Development\/Ecommerce_Tracking\/index.html"},{"title":"Events","text":"CoreShop Events CoreShop comes with a lot of build-in events. Frontend Controller Name EventType Description coreshop.customer.update_post ResourceControllerEvent Fires after Customer has updated the profile coreshop.customer.change_password_post ResourceControllerEvent Fires after Customer has changed the password coreshop.customer.newsletter_confirm_post ResourceControllerEvent Fires after Customer has confirmed his newsletter subscription coreshop.address.add_post ResourceControllerEvent Fires after Customer has added a new address coreshop.address.update_post ResourceControllerEvent Fires after Customer has updated a address coreshop.address.delete_pre ResourceControllerEvent Fires before Customer deletes a address Cart Name EventType Description coreshop.cart.update GenericEvent Fires after cart has been updated coreshop.cart.pre_add_item GenericEvent Fires before a item gets added to cart coreshop.cart.post_add_item GenericEvent Fires after a item gets added to cart coreshop.cart.pre_remove_item GenericEvent Fires before a item gets removed from cart coreshop.cart.post_remove_item GenericEvent Fires after a item gets removed from cart Customer Name EventType Description coreshop.customer.register CustomerRegistrationEvent Fires after a new customer has been generated coreshop.customer.request_password_reset RequestPasswordChangeEvent Fires after password reset has been requested coreshop.customer.password_reset GenericEvent Fires after new password hast been applied to customer Order Document Name EventType Description coreshop.order.shipment.wkhtml.options WkhtmlOptionsEvent Options Event: Use it to change wkhtml options. coreshop.order.invoice.wkhtml.options WkhtmlOptionsEvent Options Event: Use it to change wkhtml options. Payment Name EventType Description coreshop.payment_provider.supports PaymentProviderSupportsEvent Support Event: Use it to modify available Payment Providers Notes Name EventType Description coreshop.note.*.post_add GenericEvent Fires after a note of type * has been created coreshop.note.*.post_delete GenericEvent Fires after a note of type * has been deleted Rules Name EventType Description coreshop.rule.availability_check RuleAvailabilityCheckEvent Fires in RuleAvailabilityCheck maintenance\/command for every active rule. Replace symbol (*) with one of those note types: payment update_order update_order_item email order_comment Workflow Name EventType Description coreshop.workflow.valid_transitions WorkflowTransitionEvent Valid Event: Use it if you need to extend the workflow transitions Transformer Name EventType Description coreshop.quote_item.pre_transform GenericEvent Fires before proposal item gets transformed to a quote item coreshop.quote_item.post_transform GenericEvent Fires after proposal item has been transformed to a quote item coreshop.order_item.pre_transform GenericEvent Fires before proposal item gets transformed to a order item coreshop.order_item.post_transform GenericEvent Fires after proposal item has been transformed to a order item coreshop.quote.pre_transform GenericEvent Fires before proposal gets transformed to a quote coreshop.quote.post_transform GenericEvent Fires after proposal has been transformed to a quote coreshop.order.pre_transform GenericEvent Fires before proposal gets transformed to a order coreshop.order.post_transform GenericEvent Fires after proposal has been transformed to a order coreshop.shipment_item.pre_transform GenericEvent Fires before proposal item gets transformed to a shipment item coreshop.shipment_item.post_transform GenericEvent Fires after proposal item has been transformed to a shipment item coreshop.shipment.pre_transform GenericEvent Fires before proposal gets transformed to a shipment coreshop.shipment.post_transform GenericEvent Fires after proposal has been transformed to a shipment coreshop.invoice.pre_transform GenericEvent Fires before proposal gets transformed to a invoice coreshop.invoice.post_transform GenericEvent Fires after proposal has been transformed to a invoice Backend Controller Name EventType Description coreshop.*.pre_create ResourceControllerEvent Fires before object gets created in backend coreshop.*.post_create ResourceControllerEvent Fires after object gets created in backend coreshop.*.pre_save ResourceControllerEvent Fires before object gets saved in backend coreshop.*.post_save ResourceControllerEvent Fires after object gets saved in backend coreshop.*.pre_delete ResourceControllerEvent Fires before object gets deleted in backend coreshop.*.post_delete ResourceControllerEvent Fires after object gets deleted in backend Replace symbol (*) with one of those controller: configuration payment_provider exchange_rate filter index notification_rule notification_rule cart_price_rule product_price_rule shipping_rule store tax_rule_group Workflow Events There are events vor every state machine transition. Read more about it here. Model Events You can use Pimcore Events for CoreShops Pimcore Models: Pimcore Events","tags":"","url":"Development\/Events\/index.html"},{"title":"Store Front","text":"CoreShop Store Front The CoreShop Store Front (FrontendBundle) comes with a default implementation and is designed to show you how to work with the CoreShop Framework. Controllers","tags":"","url":"Development\/Store_Front\/index.html"},{"title":"Controllers","text":"CoreShop Store Front Controller If you use CoreShop FrontendBundle, you can change the Controllers it uses. Simply change the configuration for the controller: core_shop_frontend: controllers: index: CoreShop\\Bundle\\FrontendBundle\\Controller\\IndexController register: CoreShop\\Bundle\\FrontendBundle\\Controller\\RegisterController customer: CoreShop\\Bundle\\FrontendBundle\\Controller\\CustomerController currency: CoreShop\\Bundle\\FrontendBundle\\Controller\\CurrencyController language: CoreShop\\Bundle\\FrontendBundle\\Controller\\LanguageController search: CoreShop\\Bundle\\FrontendBundle\\Controller\\SearchController cart: CoreShop\\Bundle\\FrontendBundle\\Controller\\CartController checkout: CoreShop\\Bundle\\FrontendBundle\\Controller\\CheckoutController category: CoreShop\\Bundle\\FrontendBundle\\Controller\\CategoryController product: CoreShop\\Bundle\\FrontendBundle\\Controller\\ProductController quote: CoreShop\\Bundle\\FrontendBundle\\Controller\\QuoteController security: CoreShop\\Bundle\\FrontendBundle\\Controller\\SecurityController payment: CoreShop\\Bundle\\PayumBundle\\Controller\\PaymentController Example of using a Custom ProductController 1: Add a new Controller and inherit from the FrontendController &lt;?php namespace AppBundle\\Controller; use CoreShop\\Component\\Core\\Model\\ProductInterface; use Symfony\\Component\\HttpFoundation\\Request; class ProductController extends \\CoreShop\\Bundle\\FrontendBundle\\Controller\\ProductController { public function detailAction(Request $request) { \/\/Do whatever you want in here return parent::detailAction($request); } } 2: Change Configuration of the Controller: core_shop_frontend: controllers: product: AppBundle\\Controller\\ProductController","tags":"","url":"Development\/Store_Front\/Controllers.html"},{"title":"State Machine","text":"CoreShop State Machine The CoreShop State Machine is a important core feature which allows to determinate complex workflows securely and in a most modern way. Unlike the most eCommerce Frameworks out there, CoreShop does not work with the messy and hard do extend &quot;state\/status&quot; concept. Every order-section and of course the order itself provides its own state machine which allows us to build a super strong state workflow. Places In State Machine context, the well-known &quot;Status&quot; Property is called &quot;Places&quot;. Every Workflow comes with a pre-defined set of Places. Transition To change the Place of a workflow we need to apply a transition. If the transition is valid the new place gets stored. Callbacks There are several events for each transition which can be also extend by every project. Example:: If all order payments has been successfully transformed to the completed place, the coreshop_order_payment workflow will automatically change to paid. Workflows There are seven implemented Workflows: coreshop_order coreshop_order_payment coreshop_order_shipment coreshop_order_invoice coreshop_payment coreshop_shipment coreshop_invoice Workflows are connected among themselves so every transition will trigger another Workflow and so on. If a transition has been dispatched, it cannot be transformed back unless it has been defined in the available transitions. So let's start: Available Workflows Create Callbacks Things to Know (!) Extend Workflows","tags":"","url":"Development\/State_Machine\/index.html"},{"title":"Available Workflows","text":"CoreShop State Machine - Available Workflows Order Sale Workflow In CoreShop 3.x the Cart, Order and Quote are the same DataObject. To differentiate between them, we use states with workflows. State Machine: coreshop_order_sales_type Available Places Name Description cart Initial State - Cart order Once the customer finishes the checkout, pre-payment, it becomes an order quote Once the customer finishes the checkout and requests a quote Available Transition Name Allowed from Places order cart cart cart quote cart Order Workflow State Machine: coreshop_order Description: The Order Workflow is the most simplest and also the most important one. Available Places Name Description initialized Initial State. Just before a order gets saved for the very first time. new a new order has been created confirmed customer has successfully placed an order cancelled order has been cancelled complete the order is complete (all payments and shipments have been successfully processed) Available Transition Name Allowed from Places create initialized confirm new cancel new, confirmed complete confirmed Visualization Order Payment Workflow State Machine: coreshop_order_payment Description: Defines the summary payment state Available Places Name Description new order has been initial created awaiting_payment a payment has been captured partially_paid one of the order payments has been paid cancelled all payments has been cancelled paid all order payments successfully paid partially_refunded one of the order payments has been refunded refunded all payments has been refunded Available Transition Name Allowed from Places request_payment new partially_pay awaiting_payment, partially_paid cancel awaiting_payment partially_refund paid, partially_paid, partially_refunded refund paid, partially_paid, partially_refunded Visualization Order Shipment Workflow State Machine: coreshop_order_shipment Description: Defines the summary shipment state Available Places Name Description new order has been initial created cancelled all shipments has been cancelled partially_shipped one of the order shipments has been shipped shipped all order shipments has been shipped Available Transition Name Allowed from Places partially_ship new cancel new ship new, partially_shipped Visualization Order Invoice Workflow State Machine: coreshop_order_invoice Description: Defines the summary invoice state Available Places Name Description new order has been initial created cancelled all invoices has been cancelled partially_invoiced one of the order invoices has been invoiced invoiced all order invoices has been successfully invoiced Available Transition Name Allowed from Places cancel new partially_invoice new invoice new, partially_invoiced Visualization Payment Workflow State Machine: coreshop_payment Description: Defines the single payment state Available Places Name Description new new payment has been created processing payment has been captured completed payment is complete failed payment has failed cancelled payment has been canceled refunded payment has been refunded Available Transition Name Allowed from Places process new complete new, processing fail new, processing cancel new, processing refund completed Visualization Shipment Workflow State Machine: coreshop_shipment Description: Defines the single shipment state Available Places Name Description new new shipment has been created ready shipment has been assigned to order cancelled shipment has been cancelled shipped shipment has been shipped Available Transition Name Allowed from Places create new ship ready cancel ready Visualization Invoice Workflow State Machine: coreshop_invoice Description: Defines the single invoice state Available Places Name Description new new invoice has been created ready invoice has been assigned to order cancelled invoice has been cancelled complete invoice has been completed Available Transition Name Allowed from Places create new cancel ready complete ready Visualization","tags":"","url":"Development\/State_Machine\/Available_Workflows.html"},{"title":"Create Callbacks","text":"CoreShop State Machine - Callbacks It's really simple to create a custom state machine callback. After Callbacks In this example we want to register a simple listener which gets triggered after a customer successfully placed a order: core_shop_workflow: state_machine: coreshop_order: callbacks: after: do_something_special: on: ['confirm'] do: ['@AppBundle\\EventListener\\SpecialListener', 'doSomething'] args: ['object'] priority: -10 # fire action early! Name Description on transition name do service and method to dispatch args object or event. Object type depends on state machine type. priority set priority. default is 0 And your Service: &lt;?php namespace AppBundle\\EventListener; use CoreShop\\Component\\Core\\Model\\CustomerInterface; use CoreShop\\Component\\Core\\Model\\OrderInterface; final class SpecialListener { \/** * @param OrderInterface $order *\/ public function doSomething(OrderInterface $order) { \/** @var CustomerInterface $customer *\/ $customer = $order-&gt;getCustomer(); \/** @var string $locale *\/ $locale = $order-&gt;getLocaleCode(); \/\/ your very special code. } } Before Callbacks In this example we want to register a simple listener which gets triggered before a the shipment transaction ready gets applied: core_shop_workflow: state_machine: coreshop_shipment: callbacks: before: check_something: on: ['create'] do: ['@AppBundle\\EventListener\\SpecialListener', 'checkSomething'] args: ['object'] priority: 0 Name Description on transition name do service and method to dispatch args object or event. Object type depends on state machine type. priority set priority. default is 0 As you can see in the class below, the checkSomething() method throws an exception. This prevents the state machine from switching to the ready state. Just remove the exception and the transition gets applied as expected. &lt;?php namespace AppBundle\\EventListener; use CoreShop\\Component\\Core\\Model\\OrderShipmentInterface; final class SpecialListener { \/** * @param OrderShipmentInterface $shipment *\/ public function checkSomething(OrderShipmentInterface $shipment) { \/\/ check something and throw an exeption throw new \\Exception('something is wrong...'); } }","tags":"","url":"Development\/State_Machine\/Create_Callbacks.html"},{"title":"Things To Know","text":"CoreShop State Machine - Important Things to Know Canceling Orders Within the CoreShop workflow architecture a lot of orders may stay forever in the new or confirmed state. CoreShop will automatically cancel orders older than 20 days under following conditions: Order creationDate &gt;= 20 days ago Order State is initialized or new or confirmed Order Payment State is not paid Read more about automation here. Expire Orders via Backend There is also a cancel button in the order detail section. Expire Orders via Command There is also a command for that: $ coreshop:order:expire Change Orders Expiration Date core_shop_order: expiration: order: days: 30","tags":"","url":"Development\/State_Machine\/Things_To_Know.html"},{"title":"Extend Workflows","text":"CoreShop State Machine - Extend Workflows It's possible to extend all available CoreShop Workflow. Example A: Extend Shipment Workflow Workflow Configuration core_shop_workflow: state_machine: coreshop_shipment: # define a new place &quot;reviewed&quot; places: - reviewed # define a new transition &quot;review&quot; transitions: review: from: [new, ready] to: reviewed # add some colors for better ux place_colors: reviewed: '#2f819e' transition_colors: review: '#2f819e' Add translations Just use the Pimcore Backend\/Frontend translation or just add it via default symfony translation context: # app\/Resources\/translations\/admin.en.yml coreshop_workflow_transition_coreshop_shipment_review: 'Review' coreshop_workflow_state_coreshop_shipment_reviewed: 'Reviewed' # app\/Resources\/translations\/messages.en.yml coreshop.ui.workflow.state.coreshop_shipment.reviewed: 'Shipment under Review' Inform CoreShop about new Transition of Shipment Workflow Not all transitions should be available in backend. To allow the transition to show up, you need to implement a simple event listener: # app\/config\/services AppBundle\\EventListener\\WorkflowListener: autowire: true tags: - { name: kernel.event_listener, event: coreshop.workflow.valid_transitions, method: parseTransitions} &lt;?php namespace AppBundle\\EventListener; use CoreShop\\Bundle\\OrderBundle\\Event\\WorkflowTransitionEvent; class WorkflowListener { public function parseTransitions(WorkflowTransitionEvent $event) { $workflowName = $event-&gt;getWorkflowName(); if($workflowName === 'coreshop_shipment') { $event-&gt;addAllowedTransitions(['review']); } } } Example B: Change default Transition Behaviour of Shipment Workflow Note: Be careful while changing transitions. Test your application if a workflow still runs smoothly after changing it! In this example we want to change the default shipping behavior. Workflow before: ready -&gt; shipped -&gt; cancelled Workflow after: ready -&gt; reviewed -&gt; shipped -&gt; cancelled Workflow Configuration core_shop_workflow: state_machine: coreshop_shipment: # define a new place &quot;reviewed&quot; places: - reviewed # define a new transition &quot;review&quot; transitions: review: from: [ready] to: reviewed # override the default &quot;ship&quot; transition # which only allows [ready] as valid &quot;from&quot; dispatcher ship: from: [reviewed] to: shipped # add some colors for better ux place_colors: reviewed: '#2f819e' transition_colors: review: '#2f819e' Example C: Callback Listener If you need to implement some further business logic after the coreshop_shipment state has changed to reviewed you need to define a callback: Note: Please make sure your service is public available! core_shop_workflow: state_machine: coreshop_shipment: callbacks: after: do_something_after_review: on: ['review'] do: ['@your_service', 'yourAction'] # in this context, &quot;object&quot; is the shipment item args: ['object'] priority: -10 # fire action early!","tags":"","url":"Development\/State_Machine\/Extend_Workflows.html"},{"title":"Inventory","text":"CoreShop Inventory Twig Helper There are some Helpers to check the product inventory. Inventory Available {% if coreshop_inventory_is_available(product) %} {# show cart button since there is at least one item available #} {% endif %} Inventory is Sufficient {% if coreshop_inventory_is_sufficient(product, 10) %} {# do something here since there are at least 10 items available #} {% endif %}","tags":"","url":"Development\/Inventory\/index.html"},{"title":"SEO","text":"CoreShop SEO Usage","tags":"","url":"Development\/SEO\/index.html"},{"title":"Currency Fractions","text":"CoreShop Fraction Digits CoreShop allows you working with more than 2 digits for Currency Values. The default configuration looks like this: core_shop_currency: money_decimal_precision: 2 money_decimal_factor: 100 money_decimal_precision: 2 Having a global precision of 2 money_decimal_factor: 100 Displaying Currency with a factor of 100 (in Pimcore Backend). WARNING If you change these settings in an existing Installation with Orders\/Products etc. you also have to create a migration to change all the values from a precision of 2 to your new setting. In order to handle payment values with a precision of for example 4, we introduced a new Order Property called paymentTotal. Within a Payment, you cannot deal with a precision &gt; 2, since a currency only has eg. 100 Cents. Therefore, we round the total Cart\/Order value to a precision of 2 into the paymentTotal Value. For example: Your Cart\/Order is &quot;\u20ac 1.000,5498&quot;, your payment total then is: &quot;\u20ac 1.000,55&quot;. If you want to display the payment total in your cart, you can use this template: {% if currency.convertAndFormat(cart.total) != currency.convertAndFormat(cart.paymentTotal, 2, 100) %} &lt;tr&gt; &lt;td class=&quot;text-right&quot; colspan=&quot;3&quot;&gt; &lt;strong&gt;{{ 'coreshop.ui.payment_total'|trans }}:&lt;\/strong&gt; &lt;\/td&gt; &lt;td colspan=&quot;2&quot; class=&quot;text-right cart-total-payment-price&quot;&gt; {{ currency.convertAndFormat(cart.paymentTotal, 2, 100) }} &lt;\/td&gt; &lt;\/tr&gt; {% endif %} c","tags":"","url":"Development\/Currency_Fractions\/index.html"}]}